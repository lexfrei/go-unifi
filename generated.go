// Package unifi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package unifi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for HostType.
const (
	Console       HostType = "console"
	NetworkServer HostType = "network-server"
)

// Defines values for ISPMetricsQueryInterval.
const (
	N1h ISPMetricsQueryInterval = "1h"
	N5m ISPMetricsQueryInterval = "5m"
)

// Defines values for ISPMetricsQueryResponseDataStatus.
const (
	PartialSuccess ISPMetricsQueryResponseDataStatus = "partialSuccess"
	Success        ISPMetricsQueryResponseDataStatus = "success"
)

// AutoUpdateConfig defines model for AutoUpdateConfig.
type AutoUpdateConfig struct {
	IncludeApplications *bool       `json:"includeApplications,omitempty"`
	PreferencesPrompt   interface{} `json:"preferencesPrompt"`
	Schedule            *struct {
		// Frequency Update frequency (daily, weekly, etc.)
		Frequency *string `json:"frequency,omitempty"`

		// Hour Hour of day for updates (0-23)
		Hour *int `json:"hour,omitempty"`
	} `json:"schedule,omitempty"`
}

// ConsoleGroupMember defines model for ConsoleGroupMember.
type ConsoleGroupMember struct {
	Mac            *string `json:"mac,omitempty"`
	Role           *string `json:"role,omitempty"`
	RoleAttributes *struct {
		Applications *map[string]struct {
			Owned     *bool `json:"owned,omitempty"`
			Required  *bool `json:"required,omitempty"`
			Supported *bool `json:"supported,omitempty"`
		} `json:"applications,omitempty"`
		CandidateRoles            *[]string  `json:"candidateRoles,omitempty"`
		ConnectedState            *string    `json:"connectedState,omitempty"`
		ConnectedStateLastChanged *time.Time `json:"connectedStateLastChanged,omitempty"`
	} `json:"roleAttributes,omitempty"`
	SysId *int `json:"sysId,omitempty"`
}

// Controller defines model for Controller.
type Controller struct {
	ControllerStatus        *string                 `json:"controllerStatus,omitempty"`
	Features                *map[string]bool        `json:"features,omitempty"`
	HandledRequirements     *map[string]interface{} `json:"handledRequirements,omitempty"`
	InitialDeviceListSynced *bool                   `json:"initialDeviceListSynced,omitempty"`

	// InstallState Installation state (updateFailed, uninstalled, etc.)
	InstallState    *string `json:"installState,omitempty"`
	IntegrationApis *[]struct {
		ApiDocsLocation *string `json:"apiDocsLocation,omitempty"`
		Name            *string `json:"name,omitempty"`
		Version         *string `json:"version,omitempty"`
	} `json:"integrationApis,omitempty"`
	IsConfigured *bool `json:"isConfigured,omitempty"`
	IsInstalled  *bool `json:"isInstalled,omitempty"`
	IsRunning    *bool `json:"isRunning,omitempty"`

	// Name Controller name (network, protect, access, etc.)
	Name     *string   `json:"name,omitempty"`
	Port     *int      `json:"port,omitempty"`
	Prefetch *[]string `json:"prefetch,omitempty"`

	// ReleaseChannel Release channel (release, beta, etc.)
	ReleaseChannel *string `json:"releaseChannel,omitempty"`
	Required       *bool   `json:"required,omitempty"`

	// State Controller state (active, inactive)
	State *string `json:"state,omitempty"`

	// Status Status (ok, offline)
	Status        *string `json:"status,omitempty"`
	StatusMessage *string `json:"statusMessage,omitempty"`
	SwaiVersion   *int    `json:"swaiVersion,omitempty"`

	// Type Controller type
	Type             *string        `json:"type,omitempty"`
	UiVersion        *string        `json:"uiVersion,omitempty"`
	UnadoptedDevices *[]interface{} `json:"unadoptedDevices,omitempty"`
	Updatable        *bool          `json:"updatable,omitempty"`

	// UpdateAvailable Version available for update
	UpdateAvailable *string `json:"updateAvailable"`

	// UpdateProgress Update progress percentage
	UpdateProgress *int `json:"updateProgress,omitempty"`
	UpdateSchedule *struct {
		Frequency *string `json:"frequency,omitempty"`
		Hour      *int    `json:"hour,omitempty"`
	} `json:"updateSchedule,omitempty"`
	Version *string `json:"version,omitempty"`

	// VersionRaw Raw version string
	VersionRaw *string `json:"versionRaw,omitempty"`
}

// Device defines model for Device.
type Device struct {
	// Devices List of devices managed by this host
	Devices *[]DeviceItem `json:"devices,omitempty"`

	// HostId Unique identifier of the host device
	HostId *string `json:"hostId,omitempty"`

	// HostName Name of the host device
	HostName *string   `json:"hostName,omitempty"`
	Uidb     *UidbInfo `json:"uidb,omitempty"`

	// UpdatedAt Last update time in RFC3339 format
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceFeatures defines model for DeviceFeatures.
type DeviceFeatures struct {
	AlarmManager   *bool `json:"alarmManager,omitempty"`
	ApiIntegration *bool `json:"apiIntegration,omitempty"`
	Applications   *struct {
		Access *struct {
			MspPlayback *bool `json:"mspPlayback,omitempty"`
		} `json:"access,omitempty"`
	} `json:"applications,omitempty"`
	CaptiveProxy *bool `json:"captiveProxy,omitempty"`
	Cloud        *struct {
		ApplicationEvents     *bool `json:"applicationEvents,omitempty"`
		ApplicationEventsHttp *bool `json:"applicationEventsHttp,omitempty"`
		Ucp4GuestConnection   *bool `json:"ucp4GuestConnection,omitempty"`
	} `json:"cloud,omitempty"`
	CloudBackup      *bool `json:"cloudBackup,omitempty"`
	CustomSmtpServer *bool `json:"customSmtpServer,omitempty"`
	DeviceList       *struct {
		AutolinkDevices *bool `json:"autolinkDevices,omitempty"`
		PartialUpdates  *bool `json:"partialUpdates,omitempty"`
		Ucp4Events      *bool `json:"ucp4Events,omitempty"`
	} `json:"deviceList,omitempty"`
	DirectRemoteConnection *bool `json:"directRemoteConnection,omitempty"`
	HasBezel               *bool `json:"hasBezel,omitempty"`
	HasGateway             *bool `json:"hasGateway,omitempty"`
	HasLCM                 *bool `json:"hasLCM,omitempty"`
	HasLED                 *bool `json:"hasLED,omitempty"`
	Identity               *struct {
		HostingIdentityHubScore *int  `json:"hostingIdentityHubScore,omitempty"`
		Standard                *bool `json:"standard,omitempty"`
		Ucs                     *bool `json:"ucs,omitempty"`
		UcsAgent                *bool `json:"ucsAgent,omitempty"`
		UcsRemoteAccessViaUOS   *bool `json:"ucsRemoteAccessViaUOS,omitempty"`
		UnifiedAdminsUsersPage  *bool `json:"unifiedAdminsUsersPage,omitempty"`
	} `json:"identity,omitempty"`
	InfoApis *struct {
		FirmwareUpdate *bool `json:"firmwareUpdate,omitempty"`
	} `json:"infoApis,omitempty"`
	IsAutomaticFailoverAvailable *bool `json:"isAutomaticFailoverAvailable,omitempty"`
	Led                          *struct {
		CanSetColor *bool `json:"canSetColor,omitempty"`
	} `json:"led,omitempty"`
	Mfa                     *bool   `json:"mfa,omitempty"`
	MspBridgeModesSupported *bool   `json:"mspBridgeModesSupported,omitempty"`
	NetInAppBackupSupport   *bool   `json:"netInAppBackupSupport,omitempty"`
	Notifications           *bool   `json:"notifications,omitempty"`
	SharedTokens            *bool   `json:"sharedTokens,omitempty"`
	SnmpConfig              *bool   `json:"snmpConfig,omitempty"`
	SupportForm             *bool   `json:"supportForm,omitempty"`
	Syslog                  *bool   `json:"syslog,omitempty"`
	Teleport                *bool   `json:"teleport,omitempty"`
	TeleportState           *string `json:"teleportState,omitempty"`
	UidService              *bool   `json:"uidService,omitempty"`
	Updates                 *struct {
		ApplicationReleaseChannels *bool `json:"applicationReleaseChannels,omitempty"`
		ApplicationSchedules       *bool `json:"applicationSchedules,omitempty"`
	} `json:"updates,omitempty"`
}

// DeviceItem Individual device information
type DeviceItem struct {
	// AdoptionTime Time when device was adopted
	AdoptionTime *time.Time `json:"adoptionTime,omitempty"`

	// FirmwareStatus Firmware status (upToDate, updateAvailable, etc.)
	FirmwareStatus *string `json:"firmwareStatus,omitempty"`

	// Id Device ID (usually MAC address)
	Id *string `json:"id,omitempty"`

	// Ip Device IP address
	Ip *string `json:"ip,omitempty"`

	// IsConsole Whether this device is a console
	IsConsole *bool `json:"isConsole,omitempty"`

	// IsManaged Whether this device is managed
	IsManaged *bool `json:"isManaged,omitempty"`

	// Mac Device MAC address
	Mac *string `json:"mac,omitempty"`

	// Model Device model name
	Model *string `json:"model,omitempty"`

	// Name Device name
	Name *string `json:"name,omitempty"`

	// Note User-defined note
	Note *string `json:"note"`

	// ProductLine Product line (network, protect, access, etc.)
	ProductLine *string `json:"productLine,omitempty"`

	// Shortname Short model name
	Shortname *string `json:"shortname,omitempty"`

	// StartupTime Last startup time
	StartupTime *time.Time `json:"startupTime,omitempty"`

	// Status Device status (online, offline, etc.)
	Status *string   `json:"status,omitempty"`
	Uidb   *UidbInfo `json:"uidb,omitempty"`

	// UpdateAvailable Available update version if any
	UpdateAvailable *string `json:"updateAvailable"`

	// Version Current firmware version
	Version *string `json:"version,omitempty"`
}

// DevicesResponse defines model for DevicesResponse.
type DevicesResponse struct {
	Data []Device `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// Message Human-readable error message
	Message string `json:"message"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// FirmwareUpdateInfo defines model for FirmwareUpdateInfo.
type FirmwareUpdateInfo struct {
	// LatestAvailableVersion Latest firmware version available
	LatestAvailableVersion *string `json:"latestAvailableVersion"`
}

// HardwareInfo defines model for HardwareInfo.
type HardwareInfo struct {
	// Bom Bill of materials number
	Bom *string `json:"bom,omitempty"`

	// CpuId CPU identifier
	CpuId *string `json:"cpu.id,omitempty"`

	// DebianCodename Debian codename
	DebianCodename  *string `json:"debianCodename,omitempty"`
	FirmwareVersion *string `json:"firmwareVersion,omitempty"`

	// Hwrev Hardware revision
	Hwrev *int `json:"hwrev,omitempty"`

	// Mac MAC address
	Mac *string `json:"mac,omitempty"`

	// Name Hardware model name
	Name *string `json:"name,omitempty"`

	// Qrid QR code identifier
	Qrid *string `json:"qrid,omitempty"`

	// Reboot Reboot duration in seconds
	Reboot *string `json:"reboot,omitempty"`

	// Serialno Serial number
	Serialno *string `json:"serialno,omitempty"`

	// Shortname Short model name (e.g., UDR7)
	Shortname *string `json:"shortname,omitempty"`
	Subtype   *string `json:"subtype,omitempty"`

	// Sysid System identifier
	Sysid *int `json:"sysid,omitempty"`

	// Upgrade Upgrade duration in seconds
	Upgrade *string `json:"upgrade,omitempty"`

	// Uuid Hardware UUID
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`
}

// Host defines model for Host.
type Host struct {
	// HardwareId Hardware identifier of the device
	HardwareId string `json:"hardwareId"`

	// Id Unique identifier of the host device
	Id string `json:"id"`

	// IpAddress Current IP address of the device
	IpAddress *string `json:"ipAddress,omitempty"`

	// IsBlocked Indicates if the device is blocked from cloud access
	IsBlocked *bool `json:"isBlocked,omitempty"`

	// LastConnectionStateChange Time in RFC3339 format when the connection state last changed
	LastConnectionStateChange *time.Time `json:"lastConnectionStateChange,omitempty"`

	// LatestBackupTime Time in RFC3339 format of the latest device backup
	LatestBackupTime *time.Time `json:"latestBackupTime,omitempty"`

	// Owner Indicates if the current user is the owner of this device
	Owner *bool `json:"owner,omitempty"`

	// RegistrationTime Time in RFC3339 format when the device was registered to the cloud
	RegistrationTime *time.Time `json:"registrationTime,omitempty"`

	// ReportedState Device's reported state information
	ReportedState *Host_ReportedState `json:"reportedState,omitempty"`

	// Type Type of the device (console, network-server)
	Type HostType `json:"type"`

	// UserData User-specific data associated with the device including permissions and role information
	UserData *Host_UserData `json:"userData,omitempty"`
}

// Host_ReportedState_Wans_Item defines model for Host.ReportedState.Wans.Item.
type Host_ReportedState_Wans_Item struct {
	AssociatedInterface  *string                `json:"associatedInterface,omitempty"`
	Enabled              *bool                  `json:"enabled,omitempty"`
	Interface            *string                `json:"interface,omitempty"`
	Ipv4                 *string                `json:"ipv4,omitempty"`
	Mac                  *string                `json:"mac,omitempty"`
	Plugged              *bool                  `json:"plugged,omitempty"`
	Port                 *int                   `json:"port,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Host_ReportedState Device's reported state information
type Host_ReportedState struct {
	// Anonid Anonymous device identifier
	Anonid *openapi_types.UUID `json:"anonid,omitempty"`

	// Apps Installed applications with their status and features
	Apps       *[]ReportedStateApp `json:"apps,omitempty"`
	AutoUpdate *AutoUpdateConfig   `json:"autoUpdate,omitempty"`

	// AvailableChannels Available release channels
	AvailableChannels *[]string `json:"availableChannels,omitempty"`

	// ConsolesOnSameLocalNetwork Other consoles on the same local network
	ConsolesOnSameLocalNetwork *[]map[string]interface{} `json:"consolesOnSameLocalNetwork,omitempty"`

	// ControllerUuid Controller UUID
	ControllerUuid *string `json:"controller_uuid,omitempty"`

	// Controllers Installed controllers with their configuration and status
	Controllers *[]Controller `json:"controllers,omitempty"`

	// Country Country code
	Country *int `json:"country,omitempty"`

	// DeviceErrorCode Device error code if any
	DeviceErrorCode *string `json:"deviceErrorCode"`

	// DeviceState Current device state
	DeviceState *string `json:"deviceState,omitempty"`

	// DeviceStateLastChanged Unix timestamp when device state last changed
	DeviceStateLastChanged *int `json:"deviceStateLastChanged,omitempty"`

	// DirectConnectDomain Direct connect domain for remote access
	DirectConnectDomain *string             `json:"directConnectDomain,omitempty"`
	Features            *DeviceFeatures     `json:"features,omitempty"`
	FirmwareUpdate      *FirmwareUpdateInfo `json:"firmwareUpdate,omitempty"`
	Hardware            *HardwareInfo       `json:"hardware,omitempty"`

	// HostType Host type identifier
	HostType *int `json:"host_type,omitempty"`

	// Hostname Device hostname
	Hostname           *string         `json:"hostname,omitempty"`
	InternetIssues5min *InternetIssues `json:"internetIssues5min,omitempty"`

	// Ip Public IP address
	Ip *string `json:"ip,omitempty"`

	// IpAddrs List of all IP addresses assigned to the device
	IpAddrs *[]string `json:"ipAddrs,omitempty"`

	// IsStacked Indicates if device is part of a stack
	IsStacked *bool `json:"isStacked,omitempty"`

	// Location Physical location of the device
	Location *struct {
		// Lat Latitude
		Lat *float32 `json:"lat,omitempty"`

		// Long Longitude
		Long *float32 `json:"long,omitempty"`

		// Radius Location radius in meters
		Radius *float32 `json:"radius,omitempty"`

		// Text Location description
		Text *string `json:"text,omitempty"`
	} `json:"location,omitempty"`

	// Mac MAC address
	Mac *string `json:"mac,omitempty"`

	// MgmtPort Management port number
	MgmtPort *int `json:"mgmt_port,omitempty"`

	// Name Device name
	Name *string `json:"name,omitempty"`

	// ReleaseChannel Current release channel
	ReleaseChannel *string `json:"releaseChannel,omitempty"`

	// State Connection state
	State *string `json:"state,omitempty"`

	// Timezone Device timezone
	Timezone *string   `json:"timezone,omitempty"`
	Uidb     *UidbInfo `json:"uidb,omitempty"`

	// UnadoptedUnifiOSDevices List of unadopted UniFi OS devices
	UnadoptedUnifiOSDevices *[]map[string]interface{} `json:"unadoptedUnifiOSDevices,omitempty"`

	// Version UniFi OS version
	Version *string `json:"version,omitempty"`

	// Wans WAN interfaces configuration
	Wans                 *[]Host_ReportedState_Wans_Item `json:"wans,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// HostType Type of the device (console, network-server)
type HostType string

// Host_UserData User-specific data associated with the device including permissions and role information
type Host_UserData struct {
	// Apps List of installed applications
	Apps *[]string `json:"apps,omitempty"`

	// ConsoleGroupMembers Console group members information
	ConsoleGroupMembers *[]ConsoleGroupMember `json:"consoleGroupMembers,omitempty"`

	// Controllers List of available controllers
	Controllers *[]string `json:"controllers,omitempty"`

	// Email User email address
	Email    *openapi_types.Email `json:"email,omitempty"`
	Features *UserDataFeatures    `json:"features,omitempty"`

	// FullName User's full name
	FullName *string `json:"fullName,omitempty"`

	// LocalId Local user identifier
	LocalId *openapi_types.UUID `json:"localId,omitempty"`

	// Permissions User permissions per application
	Permissions *map[string][]string `json:"permissions,omitempty"`

	// Role User role
	Role *string `json:"role,omitempty"`

	// RoleId Role identifier
	RoleId *openapi_types.UUID `json:"roleId,omitempty"`

	// Status User status
	Status               *string                `json:"status,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// HostResponse defines model for HostResponse.
type HostResponse struct {
	Data Host `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// HostsResponse defines model for HostsResponse.
type HostsResponse struct {
	Data []Host `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ISPMetric defines model for ISPMetric.
type ISPMetric struct {
	// Timestamp Metric timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Type Metric type
	Type *string `json:"type,omitempty"`

	// Value Metric value
	Value                *float32               `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ISPMetricsQuery defines model for ISPMetricsQuery.
type ISPMetricsQuery struct {
	// EndTime Query end time
	EndTime *time.Time `json:"endTime,omitempty"`

	// Interval Metric interval (5-minute or 1-hour)
	Interval *ISPMetricsQueryInterval `json:"interval,omitempty"`

	// Sites List of site IDs to query
	Sites *[]string `json:"sites,omitempty"`

	// StartTime Query start time
	StartTime *time.Time `json:"startTime,omitempty"`
}

// ISPMetricsQueryInterval Metric interval (5-minute or 1-hour)
type ISPMetricsQueryInterval string

// ISPMetricsQueryResponse defines model for ISPMetricsQueryResponse.
type ISPMetricsQueryResponse struct {
	Data struct {
		Metrics *[]ISPMetric `json:"metrics,omitempty"`

		// Status Query status (partialSuccess if some sites are inaccessible)
		Status *ISPMetricsQueryResponseDataStatus `json:"status,omitempty"`
	} `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ISPMetricsQueryResponseDataStatus Query status (partialSuccess if some sites are inaccessible)
type ISPMetricsQueryResponseDataStatus string

// ISPMetricsResponse defines model for ISPMetricsResponse.
type ISPMetricsResponse struct {
	Data []ISPMetric `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// InternetIssues defines model for InternetIssues.
type InternetIssues struct {
	Periods *[]struct {
		// Index Time period index
		Index *int `json:"index,omitempty"`
	} `json:"periods,omitempty"`
}

// ReportedStateApp defines model for ReportedStateApp.
type ReportedStateApp struct {
	// ControllerStatus Controller status
	ControllerStatus *string `json:"controllerStatus,omitempty"`

	// Features App features map
	Features *map[string]bool `json:"features,omitempty"`

	// Flags App flags
	Flags            *[]string `json:"flags,omitempty"`
	IdentityFeatures *struct {
		HostingIdentityHubScore *int  `json:"hostingIdentityHubScore,omitempty"`
		Standard                *bool `json:"standard,omitempty"`
		Ucs                     *bool `json:"ucs,omitempty"`
		UcsAgent                *bool `json:"ucsAgent,omitempty"`
		UcsRemoteAccessViaUOS   *bool `json:"ucsRemoteAccessViaUOS,omitempty"`
		UnifiedAdminsUsersPage  *bool `json:"unifiedAdminsUsersPage,omitempty"`
	} `json:"identityFeatures,omitempty"`
	IdentityState *struct {
		EnterpriseActivated    *bool   `json:"enterpriseActivated,omitempty"`
		MigrationNeeded        *bool   `json:"migrationNeeded,omitempty"`
		MigrationStatus        *string `json:"migrationStatus,omitempty"`
		MigrationStatusMessage *string `json:"migrationStatusMessage,omitempty"`
		OrganizationManaged    *bool   `json:"organizationManaged,omitempty"`
		StandardActivated      *bool   `json:"standardActivated,omitempty"`
		UcsActivated           *bool   `json:"ucsActivated,omitempty"`
		UcsAgentActivated      *bool   `json:"ucsAgentActivated,omitempty"`
		UcsAgentVersion        *string `json:"ucsAgentVersion,omitempty"`
		UcsSetuped             *bool   `json:"ucsSetuped,omitempty"`
		UcsVersion             *string `json:"ucsVersion,omitempty"`
		UsersOrAdminsExist     *bool   `json:"usersOrAdminsExist,omitempty"`
	} `json:"identityState,omitempty"`
	IsConfigured *bool   `json:"isConfigured,omitempty"`
	IsInstalled  *bool   `json:"isInstalled,omitempty"`
	IsRunning    *bool   `json:"isRunning,omitempty"`
	Name         *string `json:"name,omitempty"`
	Port         *int    `json:"port,omitempty"`

	// Prefetch Prefetch resources list
	Prefetch *[]string `json:"prefetch,omitempty"`

	// SwaiVersion SWAI version number
	SwaiVersion *int `json:"swaiVersion,omitempty"`

	// Type App type
	Type *string `json:"type,omitempty"`

	// UiIcon UI icon path
	UiIcon *string `json:"uiIcon,omitempty"`

	// UiVersion UI version
	UiVersion *string `json:"uiVersion,omitempty"`

	// Version App version
	Version *string `json:"version,omitempty"`
}

// SDWANConfig defines model for SDWANConfig.
type SDWANConfig struct {
	// Config SD-WAN configuration data
	Config *map[string]interface{} `json:"config,omitempty"`

	// Id Unique SD-WAN configuration identifier
	Id *string `json:"id,omitempty"`

	// Name Configuration name
	Name *string `json:"name,omitempty"`
}

// SDWANConfigResponse defines model for SDWANConfigResponse.
type SDWANConfigResponse struct {
	Data SDWANConfig `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SDWANConfigStatus defines model for SDWANConfigStatus.
type SDWANConfigStatus struct {
	// DeploymentProgress Deployment progress percentage
	DeploymentProgress *float32 `json:"deploymentProgress,omitempty"`

	// Errors List of deployment errors
	Errors *[]string `json:"errors,omitempty"`

	// Hubs Associated hub statuses
	Hubs *[]SDWANConfigStatus_Hubs_Item `json:"hubs,omitempty"`

	// Id SD-WAN configuration identifier
	Id *string `json:"id,omitempty"`
}

// SDWANConfigStatus_Hubs_Item defines model for SDWANConfigStatus.hubs.Item.
type SDWANConfigStatus_Hubs_Item struct {
	Id                   *string                `json:"id,omitempty"`
	Status               *string                `json:"status,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SDWANConfigStatusResponse defines model for SDWANConfigStatusResponse.
type SDWANConfigStatusResponse struct {
	Data SDWANConfigStatus `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SDWANConfigsResponse defines model for SDWANConfigsResponse.
type SDWANConfigsResponse struct {
	Data []SDWANConfig `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// Site defines model for Site.
type Site struct {
	// HostId Unique identifier of the host device managing this site
	HostId *string `json:"hostId,omitempty"`

	// IsOwner Indicates if the current user is the owner of this site
	IsOwner *bool     `json:"isOwner,omitempty"`
	Meta    *SiteMeta `json:"meta,omitempty"`

	// Permission Permission level of the current user for this site (admin, readonly, etc.)
	Permission *string `json:"permission,omitempty"`

	// SiteId Unique identifier of the site
	SiteId     *string         `json:"siteId,omitempty"`
	Statistics *SiteStatistics `json:"statistics,omitempty"`
}

// SiteMeta defines model for SiteMeta.
type SiteMeta struct {
	// Desc Site description
	Desc *string `json:"desc,omitempty"`

	// GatewayMac Gateway MAC address
	GatewayMac *string `json:"gatewayMac,omitempty"`

	// Name Site name
	Name *string `json:"name,omitempty"`

	// Timezone Site timezone
	Timezone *string `json:"timezone,omitempty"`
}

// SiteStatistics defines model for SiteStatistics.
type SiteStatistics struct {
	Counts *struct {
		CriticalNotification *int `json:"criticalNotification,omitempty"`
		GatewayDevice        *int `json:"gatewayDevice,omitempty"`
		GuestClient          *int `json:"guestClient,omitempty"`
		LanConfiguration     *int `json:"lanConfiguration,omitempty"`
		OfflineDevice        *int `json:"offlineDevice,omitempty"`
		OfflineGatewayDevice *int `json:"offlineGatewayDevice,omitempty"`
		OfflineWifiDevice    *int `json:"offlineWifiDevice,omitempty"`
		OfflineWiredDevice   *int `json:"offlineWiredDevice,omitempty"`
		PendingUpdateDevice  *int `json:"pendingUpdateDevice,omitempty"`
		TotalDevice          *int `json:"totalDevice,omitempty"`
		WanConfiguration     *int `json:"wanConfiguration,omitempty"`
		WifiClient           *int `json:"wifiClient,omitempty"`
		WifiConfiguration    *int `json:"wifiConfiguration,omitempty"`
		WifiDevice           *int `json:"wifiDevice,omitempty"`
		WiredClient          *int `json:"wiredClient,omitempty"`
		WiredDevice          *int `json:"wiredDevice,omitempty"`
	} `json:"counts,omitempty"`
	Gateway *struct {
		HardwareId *openapi_types.UUID `json:"hardwareId,omitempty"`

		// InspectionState Inspection state (off, on, etc.)
		InspectionState *string `json:"inspectionState,omitempty"`

		// IpsMode IPS mode (ids, ips, etc.)
		IpsMode      *string `json:"ipsMode,omitempty"`
		IpsSignature *struct {
			RulesCount *int `json:"rulesCount,omitempty"`

			// Type Signature type (ET, etc.)
			Type *string `json:"type,omitempty"`
		} `json:"ipsSignature,omitempty"`

		// Shortname Gateway model shortname
		Shortname *string `json:"shortname,omitempty"`
	} `json:"gateway,omitempty"`

	// InternetIssues List of internet issues
	InternetIssues *[]interface{} `json:"internetIssues,omitempty"`
	IspInfo        *struct {
		// Name ISP name
		Name *string `json:"name,omitempty"`

		// Organization ISP organization
		Organization *string `json:"organization,omitempty"`
	} `json:"ispInfo,omitempty"`
	Percentages *struct {
		// TxRetry TX retry percentage
		TxRetry *float32 `json:"txRetry,omitempty"`

		// WanUptime WAN uptime percentage
		WanUptime *float32 `json:"wanUptime,omitempty"`
	} `json:"percentages,omitempty"`
	WanMagic *struct {
		Available  *bool `json:"available,omitempty"`
		Enabled    *bool `json:"enabled,omitempty"`
		Subscribed *bool `json:"subscribed,omitempty"`
	} `json:"wanMagic,omitempty"`
	Wans *map[string]struct {
		// ExternalIp External IP address
		ExternalIp *string `json:"externalIp,omitempty"`
		IspInfo    *struct {
			Name         *string `json:"name,omitempty"`
			Organization *string `json:"organization,omitempty"`
		} `json:"ispInfo,omitempty"`
		WanIssues *[]interface{} `json:"wanIssues,omitempty"`

		// WanUptime WAN uptime percentage
		WanUptime *float32 `json:"wanUptime,omitempty"`
	} `json:"wans,omitempty"`
}

// SitesResponse defines model for SitesResponse.
type SitesResponse struct {
	Data []Site `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Data The actual response payload
	Data map[string]interface{} `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// UidbInfo defines model for UidbInfo.
type UidbInfo struct {
	Guid   *openapi_types.UUID `json:"guid"`
	IconId *openapi_types.UUID `json:"iconId,omitempty"`
	Id     *openapi_types.UUID `json:"id,omitempty"`

	// Images Image hash map
	Images *map[string]string `json:"images,omitempty"`
}

// UserDataFeatures defines model for UserDataFeatures.
type UserDataFeatures struct {
	DeviceGroups *bool `json:"deviceGroups,omitempty"`
	Floorplan    *struct {
		CanEdit *bool `json:"canEdit,omitempty"`
		CanView *bool `json:"canView,omitempty"`
	} `json:"floorplan,omitempty"`
	ManageApplications *bool `json:"manageApplications,omitempty"`
	Notifications      *bool `json:"notifications,omitempty"`
	Webrtc             *struct {
		IceRestart       *bool `json:"iceRestart,omitempty"`
		MediaStreams     *bool `json:"mediaStreams,omitempty"`
		MediaStreamsAV1  *bool `json:"mediaStreamsAV1,omitempty"`
		MediaStreamsH265 *bool `json:"mediaStreamsH265,omitempty"`
		TwoWayAudio      *bool `json:"twoWayAudio,omitempty"`
	} `json:"webrtc,omitempty"`
}

// BadGateway defines model for BadGateway.
type BadGateway = ErrorResponse

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// RateLimited defines model for RateLimited.
type RateLimited = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// HostIds List of host IDs to filter the results
	HostIds *[]string `form:"hostIds,omitempty" json:"hostIds,omitempty"`

	// Time Last processed timestamp of devices in RFC3339 format
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`

	// PageSize Number of items to return per page
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination to retrieve the next set of results
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListHostsParams defines parameters for ListHosts.
type ListHostsParams struct {
	// PageSize Number of items to return per page
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination to retrieve the next set of results
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// QueryISPMetricsJSONRequestBody defines body for QueryISPMetrics for application/json ContentType.
type QueryISPMetricsJSONRequestBody = ISPMetricsQuery

// Getter for additional properties for Host_ReportedState_Wans_Item. Returns the specified
// element and whether it was found
func (a Host_ReportedState_Wans_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Host_ReportedState_Wans_Item
func (a *Host_ReportedState_Wans_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Host_ReportedState_Wans_Item to handle AdditionalProperties
func (a *Host_ReportedState_Wans_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["associatedInterface"]; found {
		err = json.Unmarshal(raw, &a.AssociatedInterface)
		if err != nil {
			return fmt.Errorf("error reading 'associatedInterface': %w", err)
		}
		delete(object, "associatedInterface")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["interface"]; found {
		err = json.Unmarshal(raw, &a.Interface)
		if err != nil {
			return fmt.Errorf("error reading 'interface': %w", err)
		}
		delete(object, "interface")
	}

	if raw, found := object["ipv4"]; found {
		err = json.Unmarshal(raw, &a.Ipv4)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4': %w", err)
		}
		delete(object, "ipv4")
	}

	if raw, found := object["mac"]; found {
		err = json.Unmarshal(raw, &a.Mac)
		if err != nil {
			return fmt.Errorf("error reading 'mac': %w", err)
		}
		delete(object, "mac")
	}

	if raw, found := object["plugged"]; found {
		err = json.Unmarshal(raw, &a.Plugged)
		if err != nil {
			return fmt.Errorf("error reading 'plugged': %w", err)
		}
		delete(object, "plugged")
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &a.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
		delete(object, "port")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Host_ReportedState_Wans_Item to handle AdditionalProperties
func (a Host_ReportedState_Wans_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AssociatedInterface != nil {
		object["associatedInterface"], err = json.Marshal(a.AssociatedInterface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'associatedInterface': %w", err)
		}
	}

	if a.Enabled != nil {
		object["enabled"], err = json.Marshal(a.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if a.Interface != nil {
		object["interface"], err = json.Marshal(a.Interface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interface': %w", err)
		}
	}

	if a.Ipv4 != nil {
		object["ipv4"], err = json.Marshal(a.Ipv4)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4': %w", err)
		}
	}

	if a.Mac != nil {
		object["mac"], err = json.Marshal(a.Mac)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mac': %w", err)
		}
	}

	if a.Plugged != nil {
		object["plugged"], err = json.Marshal(a.Plugged)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plugged': %w", err)
		}
	}

	if a.Port != nil {
		object["port"], err = json.Marshal(a.Port)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'port': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Host_ReportedState. Returns the specified
// element and whether it was found
func (a Host_ReportedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Host_ReportedState
func (a *Host_ReportedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Host_ReportedState to handle AdditionalProperties
func (a *Host_ReportedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["anonid"]; found {
		err = json.Unmarshal(raw, &a.Anonid)
		if err != nil {
			return fmt.Errorf("error reading 'anonid': %w", err)
		}
		delete(object, "anonid")
	}

	if raw, found := object["apps"]; found {
		err = json.Unmarshal(raw, &a.Apps)
		if err != nil {
			return fmt.Errorf("error reading 'apps': %w", err)
		}
		delete(object, "apps")
	}

	if raw, found := object["autoUpdate"]; found {
		err = json.Unmarshal(raw, &a.AutoUpdate)
		if err != nil {
			return fmt.Errorf("error reading 'autoUpdate': %w", err)
		}
		delete(object, "autoUpdate")
	}

	if raw, found := object["availableChannels"]; found {
		err = json.Unmarshal(raw, &a.AvailableChannels)
		if err != nil {
			return fmt.Errorf("error reading 'availableChannels': %w", err)
		}
		delete(object, "availableChannels")
	}

	if raw, found := object["consolesOnSameLocalNetwork"]; found {
		err = json.Unmarshal(raw, &a.ConsolesOnSameLocalNetwork)
		if err != nil {
			return fmt.Errorf("error reading 'consolesOnSameLocalNetwork': %w", err)
		}
		delete(object, "consolesOnSameLocalNetwork")
	}

	if raw, found := object["controller_uuid"]; found {
		err = json.Unmarshal(raw, &a.ControllerUuid)
		if err != nil {
			return fmt.Errorf("error reading 'controller_uuid': %w", err)
		}
		delete(object, "controller_uuid")
	}

	if raw, found := object["controllers"]; found {
		err = json.Unmarshal(raw, &a.Controllers)
		if err != nil {
			return fmt.Errorf("error reading 'controllers': %w", err)
		}
		delete(object, "controllers")
	}

	if raw, found := object["country"]; found {
		err = json.Unmarshal(raw, &a.Country)
		if err != nil {
			return fmt.Errorf("error reading 'country': %w", err)
		}
		delete(object, "country")
	}

	if raw, found := object["deviceErrorCode"]; found {
		err = json.Unmarshal(raw, &a.DeviceErrorCode)
		if err != nil {
			return fmt.Errorf("error reading 'deviceErrorCode': %w", err)
		}
		delete(object, "deviceErrorCode")
	}

	if raw, found := object["deviceState"]; found {
		err = json.Unmarshal(raw, &a.DeviceState)
		if err != nil {
			return fmt.Errorf("error reading 'deviceState': %w", err)
		}
		delete(object, "deviceState")
	}

	if raw, found := object["deviceStateLastChanged"]; found {
		err = json.Unmarshal(raw, &a.DeviceStateLastChanged)
		if err != nil {
			return fmt.Errorf("error reading 'deviceStateLastChanged': %w", err)
		}
		delete(object, "deviceStateLastChanged")
	}

	if raw, found := object["directConnectDomain"]; found {
		err = json.Unmarshal(raw, &a.DirectConnectDomain)
		if err != nil {
			return fmt.Errorf("error reading 'directConnectDomain': %w", err)
		}
		delete(object, "directConnectDomain")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if raw, found := object["firmwareUpdate"]; found {
		err = json.Unmarshal(raw, &a.FirmwareUpdate)
		if err != nil {
			return fmt.Errorf("error reading 'firmwareUpdate': %w", err)
		}
		delete(object, "firmwareUpdate")
	}

	if raw, found := object["hardware"]; found {
		err = json.Unmarshal(raw, &a.Hardware)
		if err != nil {
			return fmt.Errorf("error reading 'hardware': %w", err)
		}
		delete(object, "hardware")
	}

	if raw, found := object["host_type"]; found {
		err = json.Unmarshal(raw, &a.HostType)
		if err != nil {
			return fmt.Errorf("error reading 'host_type': %w", err)
		}
		delete(object, "host_type")
	}

	if raw, found := object["hostname"]; found {
		err = json.Unmarshal(raw, &a.Hostname)
		if err != nil {
			return fmt.Errorf("error reading 'hostname': %w", err)
		}
		delete(object, "hostname")
	}

	if raw, found := object["internetIssues5min"]; found {
		err = json.Unmarshal(raw, &a.InternetIssues5min)
		if err != nil {
			return fmt.Errorf("error reading 'internetIssues5min': %w", err)
		}
		delete(object, "internetIssues5min")
	}

	if raw, found := object["ip"]; found {
		err = json.Unmarshal(raw, &a.Ip)
		if err != nil {
			return fmt.Errorf("error reading 'ip': %w", err)
		}
		delete(object, "ip")
	}

	if raw, found := object["ipAddrs"]; found {
		err = json.Unmarshal(raw, &a.IpAddrs)
		if err != nil {
			return fmt.Errorf("error reading 'ipAddrs': %w", err)
		}
		delete(object, "ipAddrs")
	}

	if raw, found := object["isStacked"]; found {
		err = json.Unmarshal(raw, &a.IsStacked)
		if err != nil {
			return fmt.Errorf("error reading 'isStacked': %w", err)
		}
		delete(object, "isStacked")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if raw, found := object["mac"]; found {
		err = json.Unmarshal(raw, &a.Mac)
		if err != nil {
			return fmt.Errorf("error reading 'mac': %w", err)
		}
		delete(object, "mac")
	}

	if raw, found := object["mgmt_port"]; found {
		err = json.Unmarshal(raw, &a.MgmtPort)
		if err != nil {
			return fmt.Errorf("error reading 'mgmt_port': %w", err)
		}
		delete(object, "mgmt_port")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["releaseChannel"]; found {
		err = json.Unmarshal(raw, &a.ReleaseChannel)
		if err != nil {
			return fmt.Errorf("error reading 'releaseChannel': %w", err)
		}
		delete(object, "releaseChannel")
	}

	if raw, found := object["state"]; found {
		err = json.Unmarshal(raw, &a.State)
		if err != nil {
			return fmt.Errorf("error reading 'state': %w", err)
		}
		delete(object, "state")
	}

	if raw, found := object["timezone"]; found {
		err = json.Unmarshal(raw, &a.Timezone)
		if err != nil {
			return fmt.Errorf("error reading 'timezone': %w", err)
		}
		delete(object, "timezone")
	}

	if raw, found := object["uidb"]; found {
		err = json.Unmarshal(raw, &a.Uidb)
		if err != nil {
			return fmt.Errorf("error reading 'uidb': %w", err)
		}
		delete(object, "uidb")
	}

	if raw, found := object["unadoptedUnifiOSDevices"]; found {
		err = json.Unmarshal(raw, &a.UnadoptedUnifiOSDevices)
		if err != nil {
			return fmt.Errorf("error reading 'unadoptedUnifiOSDevices': %w", err)
		}
		delete(object, "unadoptedUnifiOSDevices")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if raw, found := object["wans"]; found {
		err = json.Unmarshal(raw, &a.Wans)
		if err != nil {
			return fmt.Errorf("error reading 'wans': %w", err)
		}
		delete(object, "wans")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Host_ReportedState to handle AdditionalProperties
func (a Host_ReportedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Anonid != nil {
		object["anonid"], err = json.Marshal(a.Anonid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anonid': %w", err)
		}
	}

	if a.Apps != nil {
		object["apps"], err = json.Marshal(a.Apps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'apps': %w", err)
		}
	}

	if a.AutoUpdate != nil {
		object["autoUpdate"], err = json.Marshal(a.AutoUpdate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autoUpdate': %w", err)
		}
	}

	if a.AvailableChannels != nil {
		object["availableChannels"], err = json.Marshal(a.AvailableChannels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'availableChannels': %w", err)
		}
	}

	if a.ConsolesOnSameLocalNetwork != nil {
		object["consolesOnSameLocalNetwork"], err = json.Marshal(a.ConsolesOnSameLocalNetwork)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'consolesOnSameLocalNetwork': %w", err)
		}
	}

	if a.ControllerUuid != nil {
		object["controller_uuid"], err = json.Marshal(a.ControllerUuid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'controller_uuid': %w", err)
		}
	}

	if a.Controllers != nil {
		object["controllers"], err = json.Marshal(a.Controllers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'controllers': %w", err)
		}
	}

	if a.Country != nil {
		object["country"], err = json.Marshal(a.Country)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'country': %w", err)
		}
	}

	if a.DeviceErrorCode != nil {
		object["deviceErrorCode"], err = json.Marshal(a.DeviceErrorCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deviceErrorCode': %w", err)
		}
	}

	if a.DeviceState != nil {
		object["deviceState"], err = json.Marshal(a.DeviceState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deviceState': %w", err)
		}
	}

	if a.DeviceStateLastChanged != nil {
		object["deviceStateLastChanged"], err = json.Marshal(a.DeviceStateLastChanged)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deviceStateLastChanged': %w", err)
		}
	}

	if a.DirectConnectDomain != nil {
		object["directConnectDomain"], err = json.Marshal(a.DirectConnectDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'directConnectDomain': %w", err)
		}
	}

	if a.Features != nil {
		object["features"], err = json.Marshal(a.Features)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'features': %w", err)
		}
	}

	if a.FirmwareUpdate != nil {
		object["firmwareUpdate"], err = json.Marshal(a.FirmwareUpdate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'firmwareUpdate': %w", err)
		}
	}

	if a.Hardware != nil {
		object["hardware"], err = json.Marshal(a.Hardware)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hardware': %w", err)
		}
	}

	if a.HostType != nil {
		object["host_type"], err = json.Marshal(a.HostType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'host_type': %w", err)
		}
	}

	if a.Hostname != nil {
		object["hostname"], err = json.Marshal(a.Hostname)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hostname': %w", err)
		}
	}

	if a.InternetIssues5min != nil {
		object["internetIssues5min"], err = json.Marshal(a.InternetIssues5min)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internetIssues5min': %w", err)
		}
	}

	if a.Ip != nil {
		object["ip"], err = json.Marshal(a.Ip)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip': %w", err)
		}
	}

	if a.IpAddrs != nil {
		object["ipAddrs"], err = json.Marshal(a.IpAddrs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipAddrs': %w", err)
		}
	}

	if a.IsStacked != nil {
		object["isStacked"], err = json.Marshal(a.IsStacked)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isStacked': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	if a.Mac != nil {
		object["mac"], err = json.Marshal(a.Mac)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mac': %w", err)
		}
	}

	if a.MgmtPort != nil {
		object["mgmt_port"], err = json.Marshal(a.MgmtPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mgmt_port': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.ReleaseChannel != nil {
		object["releaseChannel"], err = json.Marshal(a.ReleaseChannel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'releaseChannel': %w", err)
		}
	}

	if a.State != nil {
		object["state"], err = json.Marshal(a.State)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'state': %w", err)
		}
	}

	if a.Timezone != nil {
		object["timezone"], err = json.Marshal(a.Timezone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timezone': %w", err)
		}
	}

	if a.Uidb != nil {
		object["uidb"], err = json.Marshal(a.Uidb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uidb': %w", err)
		}
	}

	if a.UnadoptedUnifiOSDevices != nil {
		object["unadoptedUnifiOSDevices"], err = json.Marshal(a.UnadoptedUnifiOSDevices)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'unadoptedUnifiOSDevices': %w", err)
		}
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	if a.Wans != nil {
		object["wans"], err = json.Marshal(a.Wans)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'wans': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Host_UserData. Returns the specified
// element and whether it was found
func (a Host_UserData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Host_UserData
func (a *Host_UserData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Host_UserData to handle AdditionalProperties
func (a *Host_UserData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["apps"]; found {
		err = json.Unmarshal(raw, &a.Apps)
		if err != nil {
			return fmt.Errorf("error reading 'apps': %w", err)
		}
		delete(object, "apps")
	}

	if raw, found := object["consoleGroupMembers"]; found {
		err = json.Unmarshal(raw, &a.ConsoleGroupMembers)
		if err != nil {
			return fmt.Errorf("error reading 'consoleGroupMembers': %w", err)
		}
		delete(object, "consoleGroupMembers")
	}

	if raw, found := object["controllers"]; found {
		err = json.Unmarshal(raw, &a.Controllers)
		if err != nil {
			return fmt.Errorf("error reading 'controllers': %w", err)
		}
		delete(object, "controllers")
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if raw, found := object["fullName"]; found {
		err = json.Unmarshal(raw, &a.FullName)
		if err != nil {
			return fmt.Errorf("error reading 'fullName': %w", err)
		}
		delete(object, "fullName")
	}

	if raw, found := object["localId"]; found {
		err = json.Unmarshal(raw, &a.LocalId)
		if err != nil {
			return fmt.Errorf("error reading 'localId': %w", err)
		}
		delete(object, "localId")
	}

	if raw, found := object["permissions"]; found {
		err = json.Unmarshal(raw, &a.Permissions)
		if err != nil {
			return fmt.Errorf("error reading 'permissions': %w", err)
		}
		delete(object, "permissions")
	}

	if raw, found := object["role"]; found {
		err = json.Unmarshal(raw, &a.Role)
		if err != nil {
			return fmt.Errorf("error reading 'role': %w", err)
		}
		delete(object, "role")
	}

	if raw, found := object["roleId"]; found {
		err = json.Unmarshal(raw, &a.RoleId)
		if err != nil {
			return fmt.Errorf("error reading 'roleId': %w", err)
		}
		delete(object, "roleId")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Host_UserData to handle AdditionalProperties
func (a Host_UserData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Apps != nil {
		object["apps"], err = json.Marshal(a.Apps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'apps': %w", err)
		}
	}

	if a.ConsoleGroupMembers != nil {
		object["consoleGroupMembers"], err = json.Marshal(a.ConsoleGroupMembers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'consoleGroupMembers': %w", err)
		}
	}

	if a.Controllers != nil {
		object["controllers"], err = json.Marshal(a.Controllers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'controllers': %w", err)
		}
	}

	if a.Email != nil {
		object["email"], err = json.Marshal(a.Email)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'email': %w", err)
		}
	}

	if a.Features != nil {
		object["features"], err = json.Marshal(a.Features)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'features': %w", err)
		}
	}

	if a.FullName != nil {
		object["fullName"], err = json.Marshal(a.FullName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fullName': %w", err)
		}
	}

	if a.LocalId != nil {
		object["localId"], err = json.Marshal(a.LocalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'localId': %w", err)
		}
	}

	if a.Permissions != nil {
		object["permissions"], err = json.Marshal(a.Permissions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'permissions': %w", err)
		}
	}

	if a.Role != nil {
		object["role"], err = json.Marshal(a.Role)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'role': %w", err)
		}
	}

	if a.RoleId != nil {
		object["roleId"], err = json.Marshal(a.RoleId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'roleId': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ISPMetric. Returns the specified
// element and whether it was found
func (a ISPMetric) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ISPMetric
func (a *ISPMetric) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ISPMetric to handle AdditionalProperties
func (a *ISPMetric) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["timestamp"]; found {
		err = json.Unmarshal(raw, &a.Timestamp)
		if err != nil {
			return fmt.Errorf("error reading 'timestamp': %w", err)
		}
		delete(object, "timestamp")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ISPMetric to handle AdditionalProperties
func (a ISPMetric) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Timestamp != nil {
		object["timestamp"], err = json.Marshal(a.Timestamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timestamp': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Value != nil {
		object["value"], err = json.Marshal(a.Value)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'value': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SDWANConfigStatus_Hubs_Item. Returns the specified
// element and whether it was found
func (a SDWANConfigStatus_Hubs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SDWANConfigStatus_Hubs_Item
func (a *SDWANConfigStatus_Hubs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SDWANConfigStatus_Hubs_Item to handle AdditionalProperties
func (a *SDWANConfigStatus_Hubs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SDWANConfigStatus_Hubs_Item to handle AdditionalProperties
func (a SDWANConfigStatus_Hubs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetISPMetrics request
	GetISPMetrics(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryISPMetricsWithBody request with any body
	QueryISPMetricsWithBody(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryISPMetrics(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSDWANConfigs request
	ListSDWANConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSDWANConfigById request
	GetSDWANConfigById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSDWANConfigStatus request
	GetSDWANConfigStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDevices request
	ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHosts request
	ListHosts(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostById request
	GetHostById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSites request
	ListSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetISPMetrics(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetISPMetricsRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryISPMetricsWithBody(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryISPMetricsRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryISPMetrics(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryISPMetricsRequest(c.Server, pType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSDWANConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSDWANConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSDWANConfigById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSDWANConfigByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSDWANConfigStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSDWANConfigStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHosts(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetISPMetricsRequest generates requests for GetISPMetrics
func NewGetISPMetricsRequest(server string, pType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/isp-metrics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryISPMetricsRequest calls the generic QueryISPMetrics builder with application/json body
func NewQueryISPMetricsRequest(server string, pType string, body QueryISPMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryISPMetricsRequestWithBody(server, pType, "application/json", bodyReader)
}

// NewQueryISPMetricsRequestWithBody generates requests for QueryISPMetrics with any type of body
func NewQueryISPMetricsRequestWithBody(server string, pType string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/isp-metrics/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSDWANConfigsRequest generates requests for ListSDWANConfigs
func NewListSDWANConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSDWANConfigByIdRequest generates requests for GetSDWANConfigById
func NewGetSDWANConfigByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSDWANConfigStatusRequest generates requests for GetSDWANConfigStatus
func NewGetSDWANConfigStatusRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDevicesRequest generates requests for ListDevices
func NewListDevicesRequest(server string, params *ListDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HostIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostIds", runtime.ParamLocationQuery, *params.HostIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHostsRequest generates requests for ListHosts
func NewListHostsRequest(server string, params *ListHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostByIdRequest generates requests for GetHostById
func NewGetHostByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSitesRequest generates requests for ListSites
func NewListSitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetISPMetricsWithResponse request
	GetISPMetricsWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetISPMetricsResponse, error)

	// QueryISPMetricsWithBodyWithResponse request with any body
	QueryISPMetricsWithBodyWithResponse(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error)

	QueryISPMetricsWithResponse(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error)

	// ListSDWANConfigsWithResponse request
	ListSDWANConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSDWANConfigsResponse, error)

	// GetSDWANConfigByIdWithResponse request
	GetSDWANConfigByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigByIdResponse, error)

	// GetSDWANConfigStatusWithResponse request
	GetSDWANConfigStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigStatusResponse, error)

	// ListDevicesWithResponse request
	ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error)

	// ListHostsWithResponse request
	ListHostsWithResponse(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*ListHostsResponse, error)

	// GetHostByIdWithResponse request
	GetHostByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostByIdResponse, error)

	// ListSitesWithResponse request
	ListSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSitesResponse, error)
}

type GetISPMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ISPMetricsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetISPMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetISPMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryISPMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ISPMetricsQueryResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r QueryISPMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryISPMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSDWANConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigsResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListSDWANConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSDWANConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSDWANConfigByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetSDWANConfigByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSDWANConfigByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSDWANConfigStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigStatusResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetSDWANConfigStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSDWANConfigStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevicesResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostsResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetHostByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitesResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetISPMetricsWithResponse request returning *GetISPMetricsResponse
func (c *ClientWithResponses) GetISPMetricsWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetISPMetricsResponse, error) {
	rsp, err := c.GetISPMetrics(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetISPMetricsResponse(rsp)
}

// QueryISPMetricsWithBodyWithResponse request with arbitrary body returning *QueryISPMetricsResponse
func (c *ClientWithResponses) QueryISPMetricsWithBodyWithResponse(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error) {
	rsp, err := c.QueryISPMetricsWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryISPMetricsResponse(rsp)
}

func (c *ClientWithResponses) QueryISPMetricsWithResponse(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error) {
	rsp, err := c.QueryISPMetrics(ctx, pType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryISPMetricsResponse(rsp)
}

// ListSDWANConfigsWithResponse request returning *ListSDWANConfigsResponse
func (c *ClientWithResponses) ListSDWANConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSDWANConfigsResponse, error) {
	rsp, err := c.ListSDWANConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSDWANConfigsResponse(rsp)
}

// GetSDWANConfigByIdWithResponse request returning *GetSDWANConfigByIdResponse
func (c *ClientWithResponses) GetSDWANConfigByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigByIdResponse, error) {
	rsp, err := c.GetSDWANConfigById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSDWANConfigByIdResponse(rsp)
}

// GetSDWANConfigStatusWithResponse request returning *GetSDWANConfigStatusResponse
func (c *ClientWithResponses) GetSDWANConfigStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigStatusResponse, error) {
	rsp, err := c.GetSDWANConfigStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSDWANConfigStatusResponse(rsp)
}

// ListDevicesWithResponse request returning *ListDevicesResponse
func (c *ClientWithResponses) ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error) {
	rsp, err := c.ListDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDevicesResponse(rsp)
}

// ListHostsWithResponse request returning *ListHostsResponse
func (c *ClientWithResponses) ListHostsWithResponse(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*ListHostsResponse, error) {
	rsp, err := c.ListHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHostsResponse(rsp)
}

// GetHostByIdWithResponse request returning *GetHostByIdResponse
func (c *ClientWithResponses) GetHostByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostByIdResponse, error) {
	rsp, err := c.GetHostById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostByIdResponse(rsp)
}

// ListSitesWithResponse request returning *ListSitesResponse
func (c *ClientWithResponses) ListSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSitesResponse, error) {
	rsp, err := c.ListSites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSitesResponse(rsp)
}

// ParseGetISPMetricsResponse parses an HTTP response from a GetISPMetricsWithResponse call
func ParseGetISPMetricsResponse(rsp *http.Response) (*GetISPMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetISPMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ISPMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseQueryISPMetricsResponse parses an HTTP response from a QueryISPMetricsWithResponse call
func ParseQueryISPMetricsResponse(rsp *http.Response) (*QueryISPMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryISPMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ISPMetricsQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListSDWANConfigsResponse parses an HTTP response from a ListSDWANConfigsWithResponse call
func ParseListSDWANConfigsResponse(rsp *http.Response) (*ListSDWANConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSDWANConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetSDWANConfigByIdResponse parses an HTTP response from a GetSDWANConfigByIdWithResponse call
func ParseGetSDWANConfigByIdResponse(rsp *http.Response) (*GetSDWANConfigByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSDWANConfigByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetSDWANConfigStatusResponse parses an HTTP response from a GetSDWANConfigStatusWithResponse call
func ParseGetSDWANConfigStatusResponse(rsp *http.Response) (*GetSDWANConfigStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSDWANConfigStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListDevicesResponse parses an HTTP response from a ListDevicesWithResponse call
func ParseListDevicesResponse(rsp *http.Response) (*ListDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListHostsResponse parses an HTTP response from a ListHostsWithResponse call
func ParseListHostsResponse(rsp *http.Response) (*ListHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetHostByIdResponse parses an HTTP response from a GetHostByIdWithResponse call
func ParseGetHostByIdResponse(rsp *http.Response) (*GetHostByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListSitesResponse parses an HTTP response from a ListSitesWithResponse call
func ParseListSitesResponse(rsp *http.Response) (*ListSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"mO+gsry2Ub034enz0/8GAAD//4c0llCNggAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
