// Package sitemanager provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package sitemanager

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for HostType.
const (
	Console       HostType = "console"
	NetworkServer HostType = "network-server"
)

// Defines values for ISPMetricsQueryResponseDataStatus.
const (
	PartialSuccess ISPMetricsQueryResponseDataStatus = "partialSuccess"
	Success        ISPMetricsQueryResponseDataStatus = "success"
)

// Defines values for SDWANConfigType.
const (
	SdwanHbsp SDWANConfigType = "sdwan-hbsp"
)

// Defines values for GetISPMetricsParamsDuration.
const (
	N24h GetISPMetricsParamsDuration = "24h"
	N30d GetISPMetricsParamsDuration = "30d"
	N7d  GetISPMetricsParamsDuration = "7d"
)

// Defines values for GetISPMetricsParamsType.
const (
	N1h GetISPMetricsParamsType = "1h"
	N5m GetISPMetricsParamsType = "5m"
)

// AutoUpdateConfig defines model for AutoUpdateConfig.
type AutoUpdateConfig struct {
	IncludeApplications *bool `json:"includeApplications,omitempty"`
	PreferencesPrompt   *bool `json:"preferencesPrompt"`
	Schedule            *struct {
		// Frequency Update frequency (daily, weekly, etc.)
		Frequency *string `json:"frequency,omitempty"`

		// Hour Hour of day for updates (0-23)
		Hour *int `json:"hour,omitempty"`
	} `json:"schedule,omitempty"`
}

// ConsoleGroupMember defines model for ConsoleGroupMember.
type ConsoleGroupMember struct {
	Mac            *string `json:"mac,omitempty"`
	Role           *string `json:"role,omitempty"`
	RoleAttributes *struct {
		Applications *map[string]struct {
			Owned     *bool `json:"owned,omitempty"`
			Required  *bool `json:"required,omitempty"`
			Supported *bool `json:"supported,omitempty"`
		} `json:"applications,omitempty"`
		CandidateRoles            *[]string  `json:"candidateRoles,omitempty"`
		ConnectedState            *string    `json:"connectedState,omitempty"`
		ConnectedStateLastChanged *time.Time `json:"connectedStateLastChanged,omitempty"`
	} `json:"roleAttributes,omitempty"`
	SysId *int `json:"sysId,omitempty"`
}

// Controller defines model for Controller.
type Controller struct {
	ControllerStatus        *string                 `json:"controllerStatus,omitempty"`
	Features                *map[string]bool        `json:"features,omitempty"`
	HandledRequirements     *map[string]interface{} `json:"handledRequirements,omitempty"`
	InitialDeviceListSynced *bool                   `json:"initialDeviceListSynced,omitempty"`

	// InstallState Installation state (updateFailed, uninstalled, etc.)
	InstallState    *string `json:"installState,omitempty"`
	IntegrationApis *[]struct {
		ApiDocsLocation *string `json:"apiDocsLocation,omitempty"`
		Name            *string `json:"name,omitempty"`
		Version         *string `json:"version,omitempty"`
	} `json:"integrationApis,omitempty"`
	IsConfigured *bool `json:"isConfigured,omitempty"`
	IsInstalled  *bool `json:"isInstalled,omitempty"`
	IsRunning    *bool `json:"isRunning,omitempty"`

	// Name Controller name (network, protect, access, etc.)
	Name     *string   `json:"name,omitempty"`
	Port     *int      `json:"port,omitempty"`
	Prefetch *[]string `json:"prefetch,omitempty"`

	// ReleaseChannel Release channel (release, beta, etc.)
	ReleaseChannel *string `json:"releaseChannel,omitempty"`
	Required       *bool   `json:"required,omitempty"`

	// State Controller state (active, inactive)
	State *string `json:"state,omitempty"`

	// Status Status (ok, offline)
	Status        *string `json:"status,omitempty"`
	StatusMessage *string `json:"statusMessage,omitempty"`
	SwaiVersion   *int    `json:"swaiVersion,omitempty"`

	// Type Controller type
	Type             *string        `json:"type,omitempty"`
	UiVersion        *string        `json:"uiVersion,omitempty"`
	UnadoptedDevices *[]interface{} `json:"unadoptedDevices,omitempty"`
	Updatable        *bool          `json:"updatable,omitempty"`

	// UpdateAvailable Version available for update
	UpdateAvailable *string `json:"updateAvailable"`

	// UpdateProgress Update progress percentage
	UpdateProgress *int `json:"updateProgress,omitempty"`
	UpdateSchedule *struct {
		Frequency *string `json:"frequency,omitempty"`
		Hour      *int    `json:"hour,omitempty"`
	} `json:"updateSchedule,omitempty"`
	Version *string `json:"version,omitempty"`

	// VersionRaw Raw version string
	VersionRaw *string `json:"versionRaw,omitempty"`
}

// Device defines model for Device.
type Device struct {
	// Devices List of devices managed by this host
	Devices *[]DeviceItem `json:"devices,omitempty"`

	// HostId Unique identifier of the host device
	HostId *string `json:"hostId,omitempty"`

	// HostName Name of the host device
	HostName *string   `json:"hostName,omitempty"`
	Uidb     *UidbInfo `json:"uidb,omitempty"`

	// UpdatedAt Last update time in RFC3339 format
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceFeatures defines model for DeviceFeatures.
type DeviceFeatures struct {
	AlarmManager   *bool `json:"alarmManager,omitempty"`
	ApiIntegration *bool `json:"apiIntegration,omitempty"`
	Applications   *struct {
		Access *struct {
			MspPlayback *bool `json:"mspPlayback,omitempty"`
		} `json:"access,omitempty"`
	} `json:"applications,omitempty"`
	CaptiveProxy *bool `json:"captiveProxy,omitempty"`
	Cloud        *struct {
		ApplicationEvents     *bool `json:"applicationEvents,omitempty"`
		ApplicationEventsHttp *bool `json:"applicationEventsHttp,omitempty"`
		Ucp4GuestConnection   *bool `json:"ucp4GuestConnection,omitempty"`
	} `json:"cloud,omitempty"`
	CloudBackup      *bool `json:"cloudBackup,omitempty"`
	CustomSmtpServer *bool `json:"customSmtpServer,omitempty"`
	DeviceList       *struct {
		AutolinkDevices *bool `json:"autolinkDevices,omitempty"`
		PartialUpdates  *bool `json:"partialUpdates,omitempty"`
		Ucp4Events      *bool `json:"ucp4Events,omitempty"`
	} `json:"deviceList,omitempty"`
	DirectRemoteConnection *bool `json:"directRemoteConnection,omitempty"`
	HasBezel               *bool `json:"hasBezel,omitempty"`
	HasGateway             *bool `json:"hasGateway,omitempty"`
	HasLCM                 *bool `json:"hasLCM,omitempty"`
	HasLED                 *bool `json:"hasLED,omitempty"`
	Identity               *struct {
		HostingIdentityHubScore *int  `json:"hostingIdentityHubScore,omitempty"`
		Standard                *bool `json:"standard,omitempty"`
		Ucs                     *bool `json:"ucs,omitempty"`
		UcsAgent                *bool `json:"ucsAgent,omitempty"`
		UcsRemoteAccessViaUOS   *bool `json:"ucsRemoteAccessViaUOS,omitempty"`
		UnifiedAdminsUsersPage  *bool `json:"unifiedAdminsUsersPage,omitempty"`
	} `json:"identity,omitempty"`
	InfoApis *struct {
		FirmwareUpdate *bool `json:"firmwareUpdate,omitempty"`
	} `json:"infoApis,omitempty"`
	IsAutomaticFailoverAvailable *bool `json:"isAutomaticFailoverAvailable,omitempty"`
	Led                          *struct {
		CanSetColor *bool `json:"canSetColor,omitempty"`
	} `json:"led,omitempty"`
	Mfa                     *bool   `json:"mfa,omitempty"`
	MspBridgeModesSupported *bool   `json:"mspBridgeModesSupported,omitempty"`
	NetInAppBackupSupport   *bool   `json:"netInAppBackupSupport,omitempty"`
	Notifications           *bool   `json:"notifications,omitempty"`
	SharedTokens            *bool   `json:"sharedTokens,omitempty"`
	SnmpConfig              *bool   `json:"snmpConfig,omitempty"`
	SupportForm             *bool   `json:"supportForm,omitempty"`
	Syslog                  *bool   `json:"syslog,omitempty"`
	Teleport                *bool   `json:"teleport,omitempty"`
	TeleportState           *string `json:"teleportState,omitempty"`
	UidService              *bool   `json:"uidService,omitempty"`
	Updates                 *struct {
		ApplicationReleaseChannels *bool `json:"applicationReleaseChannels,omitempty"`
		ApplicationSchedules       *bool `json:"applicationSchedules,omitempty"`
	} `json:"updates,omitempty"`
}

// DeviceItem Individual device information
type DeviceItem struct {
	// AdoptionTime Time when device was adopted
	AdoptionTime *time.Time `json:"adoptionTime,omitempty"`

	// FirmwareStatus Firmware status (upToDate, updateAvailable, etc.)
	FirmwareStatus *string `json:"firmwareStatus,omitempty"`

	// Id Device ID (usually MAC address)
	Id *string `json:"id,omitempty"`

	// Ip Device IP address
	Ip *string `json:"ip,omitempty"`

	// IsConsole Whether this device is a console
	IsConsole *bool `json:"isConsole,omitempty"`

	// IsManaged Whether this device is managed
	IsManaged *bool `json:"isManaged,omitempty"`

	// Mac Device MAC address
	Mac *string `json:"mac,omitempty"`

	// Model Device model name
	Model *string `json:"model,omitempty"`

	// Name Device name
	Name *string `json:"name,omitempty"`

	// Note User-defined note
	Note *string `json:"note"`

	// ProductLine Product line (network, protect, access, etc.)
	ProductLine *string `json:"productLine,omitempty"`

	// Shortname Short model name
	Shortname *string `json:"shortname,omitempty"`

	// StartupTime Last startup time
	StartupTime *time.Time `json:"startupTime,omitempty"`

	// Status Device status (online, offline, etc.)
	Status *string   `json:"status,omitempty"`
	Uidb   *UidbInfo `json:"uidb,omitempty"`

	// UpdateAvailable Available update version if any
	UpdateAvailable *string `json:"updateAvailable"`

	// Version Current firmware version
	Version *string `json:"version,omitempty"`
}

// DevicesResponse defines model for DevicesResponse.
type DevicesResponse struct {
	Data []Device `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// Message Human-readable error message
	Message string `json:"message"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// FirmwareUpdateInfo defines model for FirmwareUpdateInfo.
type FirmwareUpdateInfo struct {
	// LatestAvailableVersion Latest firmware version available
	LatestAvailableVersion *string `json:"latestAvailableVersion"`
}

// HardwareInfo defines model for HardwareInfo.
type HardwareInfo struct {
	// Bom Bill of materials number
	Bom *string `json:"bom,omitempty"`

	// CpuId CPU identifier
	CpuId *string `json:"cpu.id,omitempty"`

	// DebianCodename Debian codename
	DebianCodename  *string `json:"debianCodename,omitempty"`
	FirmwareVersion *string `json:"firmwareVersion,omitempty"`

	// Hwrev Hardware revision
	Hwrev *int `json:"hwrev,omitempty"`

	// Mac MAC address
	Mac *string `json:"mac,omitempty"`

	// Name Hardware model name
	Name *string `json:"name,omitempty"`

	// Qrid QR code identifier
	Qrid *string `json:"qrid,omitempty"`

	// Reboot Reboot duration in seconds
	Reboot *string `json:"reboot,omitempty"`

	// Serialno Serial number
	Serialno *string `json:"serialno,omitempty"`

	// Shortname Short model name (e.g., UDR7)
	Shortname *string `json:"shortname,omitempty"`
	Subtype   *string `json:"subtype,omitempty"`

	// Sysid System identifier
	Sysid *int `json:"sysid,omitempty"`

	// Upgrade Upgrade duration in seconds
	Upgrade *string `json:"upgrade,omitempty"`

	// Uuid Hardware UUID
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`
}

// Host defines model for Host.
type Host struct {
	// HardwareId Hardware identifier of the device
	HardwareId string `json:"hardwareId"`

	// Id Unique identifier of the host device
	Id string `json:"id"`

	// IpAddress Current IP address of the device
	IpAddress *string `json:"ipAddress,omitempty"`

	// IsBlocked Indicates if the device is blocked from cloud access
	IsBlocked *bool `json:"isBlocked,omitempty"`

	// LastConnectionStateChange Time in RFC3339 format when the connection state last changed
	LastConnectionStateChange *time.Time `json:"lastConnectionStateChange,omitempty"`

	// LatestBackupTime Time in RFC3339 format of the latest device backup
	LatestBackupTime *time.Time `json:"latestBackupTime,omitempty"`

	// Owner Indicates if the current user is the owner of this device
	Owner *bool `json:"owner,omitempty"`

	// RegistrationTime Time in RFC3339 format when the device was registered to the cloud
	RegistrationTime *time.Time `json:"registrationTime,omitempty"`

	// ReportedState Device's reported state information
	ReportedState *struct {
		// Anonid Anonymous device identifier
		Anonid *openapi_types.UUID `json:"anonid,omitempty"`

		// Apps Installed applications with their status and features
		Apps       *[]ReportedStateApp `json:"apps,omitempty"`
		AutoUpdate *AutoUpdateConfig   `json:"autoUpdate,omitempty"`

		// AvailableChannels Available release channels
		AvailableChannels *[]string `json:"availableChannels,omitempty"`

		// ConsolesOnSameLocalNetwork Other consoles on the same local network
		ConsolesOnSameLocalNetwork *[]map[string]interface{} `json:"consolesOnSameLocalNetwork,omitempty"`

		// ControllerUuid Controller UUID
		ControllerUuid *string `json:"controller_uuid,omitempty"`

		// Controllers Installed controllers with their configuration and status
		Controllers *[]Controller `json:"controllers,omitempty"`

		// Country Country code
		Country *int `json:"country,omitempty"`

		// DeviceErrorCode Device error code if any
		DeviceErrorCode *string `json:"deviceErrorCode"`

		// DeviceState Current device state
		DeviceState *string `json:"deviceState,omitempty"`

		// DeviceStateLastChanged Unix timestamp when device state last changed
		DeviceStateLastChanged *int `json:"deviceStateLastChanged,omitempty"`

		// DirectConnectDomain Direct connect domain for remote access
		DirectConnectDomain *string             `json:"directConnectDomain,omitempty"`
		Features            *DeviceFeatures     `json:"features,omitempty"`
		FirmwareUpdate      *FirmwareUpdateInfo `json:"firmwareUpdate,omitempty"`
		Hardware            *HardwareInfo       `json:"hardware,omitempty"`

		// HostType Host type identifier
		HostType *int `json:"host_type,omitempty"`

		// Hostname Device hostname
		Hostname           *string         `json:"hostname,omitempty"`
		InternetIssues5min *InternetIssues `json:"internetIssues5min,omitempty"`

		// Ip Public IP address
		Ip *string `json:"ip,omitempty"`

		// IpAddrs List of all IP addresses assigned to the device
		IpAddrs *[]string `json:"ipAddrs,omitempty"`

		// IsStacked Indicates if device is part of a stack
		IsStacked *bool `json:"isStacked,omitempty"`

		// Location Physical location of the device
		Location *struct {
			// Lat Latitude
			Lat *float32 `json:"lat,omitempty"`

			// Long Longitude
			Long *float32 `json:"long,omitempty"`

			// Radius Location radius in meters
			Radius *float32 `json:"radius,omitempty"`

			// Text Location description
			Text *string `json:"text,omitempty"`
		} `json:"location,omitempty"`

		// Mac MAC address
		Mac *string `json:"mac,omitempty"`

		// MgmtPort Management port number
		MgmtPort *int `json:"mgmt_port,omitempty"`

		// Name Device name
		Name *string `json:"name,omitempty"`

		// ReleaseChannel Current release channel
		ReleaseChannel *string `json:"releaseChannel,omitempty"`

		// State Connection state
		State *string `json:"state,omitempty"`

		// Timezone Device timezone
		Timezone *string   `json:"timezone,omitempty"`
		Uidb     *UidbInfo `json:"uidb,omitempty"`

		// UnadoptedUnifiOSDevices List of unadopted UniFi OS devices
		UnadoptedUnifiOSDevices *[]map[string]interface{} `json:"unadoptedUnifiOSDevices,omitempty"`

		// Version UniFi OS version
		Version *string `json:"version,omitempty"`

		// Wans WAN interfaces configuration
		Wans *[]struct {
			AssociatedInterface *string `json:"associatedInterface,omitempty"`
			Enabled             *bool   `json:"enabled,omitempty"`
			Interface           *string `json:"interface,omitempty"`
			Ipv4                *string `json:"ipv4,omitempty"`
			Mac                 *string `json:"mac,omitempty"`
			Plugged             *bool   `json:"plugged,omitempty"`
			Port                *int    `json:"port,omitempty"`
			Type                *string `json:"type,omitempty"`
		} `json:"wans,omitempty"`
	} `json:"reportedState,omitempty"`

	// Type Type of the device (console, network-server)
	Type HostType `json:"type"`

	// UserData User-specific data associated with the device including permissions and role information
	UserData *struct {
		// Apps List of installed applications
		Apps *[]string `json:"apps,omitempty"`

		// ConsoleGroupMembers Console group members information
		ConsoleGroupMembers *[]ConsoleGroupMember `json:"consoleGroupMembers,omitempty"`

		// Controllers List of available controllers
		Controllers *[]string `json:"controllers,omitempty"`

		// Email User email address
		Email    *openapi_types.Email `json:"email,omitempty"`
		Features *UserDataFeatures    `json:"features,omitempty"`

		// FullName User's full name
		FullName *string `json:"fullName,omitempty"`

		// LocalId Local user identifier
		LocalId *openapi_types.UUID `json:"localId,omitempty"`

		// Permissions User permissions per application
		Permissions *map[string][]string `json:"permissions,omitempty"`

		// Role User role
		Role *string `json:"role,omitempty"`

		// RoleId Role identifier
		RoleId *openapi_types.UUID `json:"roleId,omitempty"`

		// Status User status
		Status *string `json:"status,omitempty"`
	} `json:"userData,omitempty"`
}

// HostType Type of the device (console, network-server)
type HostType string

// HostResponse defines model for HostResponse.
type HostResponse struct {
	Data Host `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// HostsResponse defines model for HostsResponse.
type HostsResponse struct {
	Data []Host `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ISPMetricItem ISP metric entry for a specific site and host
type ISPMetricItem struct {
	// HostId Host identifier
	HostId *string `json:"hostId,omitempty"`

	// MetricType Type of metric
	MetricType *string `json:"metricType,omitempty"`

	// Periods Array of metric periods
	Periods *[]ISPMetricPeriod `json:"periods,omitempty"`

	// SiteId Site identifier
	SiteId *string `json:"siteId,omitempty"`
}

// ISPMetricPeriod Metric period information
type ISPMetricPeriod struct {
	// Data Period-specific metrics data
	Data *ISPMetricPeriodData `json:"data,omitempty"`

	// MetricTime Timestamp of the metric
	MetricTime *time.Time `json:"metricTime,omitempty"`

	// Version Metric version
	Version *string `json:"version,omitempty"`
}

// ISPMetricPeriodData Period-specific metrics data
type ISPMetricPeriodData struct {
	// Wan WAN interface metrics data
	Wan *ISPMetricWanData `json:"wan,omitempty"`
}

// ISPMetricWanData WAN interface metrics data
type ISPMetricWanData struct {
	// AvgLatency Average latency in milliseconds
	AvgLatency *int `json:"avgLatency,omitempty"`

	// DownloadKbps Download speed in kbps
	DownloadKbps *int `json:"download_kbps,omitempty"`

	// Downtime Downtime duration in seconds
	Downtime *int `json:"downtime,omitempty"`

	// IspAsn ISP Autonomous System Number
	IspAsn *string `json:"ispAsn,omitempty"`

	// IspName ISP name
	IspName *string `json:"ispName,omitempty"`

	// MaxLatency Maximum latency in milliseconds
	MaxLatency *int `json:"maxLatency,omitempty"`

	// PacketLoss Packet loss percentage
	PacketLoss *int `json:"packetLoss,omitempty"`

	// UploadKbps Upload speed in kbps
	UploadKbps *int `json:"upload_kbps,omitempty"`

	// Uptime Uptime duration in seconds
	Uptime *int `json:"uptime,omitempty"`
}

// ISPMetricsQuery ISP metrics query request body
type ISPMetricsQuery struct {
	// Sites Array of sites to query with their parameters
	Sites *[]ISPMetricsQuerySiteItem `json:"sites,omitempty"`
}

// ISPMetricsQueryResponse defines model for ISPMetricsQueryResponse.
type ISPMetricsQueryResponse struct {
	Data struct {
		// Message Optional message (e.g., error details)
		Message *string `json:"message"`

		// Metrics Array of ISP metrics for queried sites
		Metrics *[]ISPMetricItem `json:"metrics,omitempty"`

		// Status Query status (partialSuccess if some sites are inaccessible)
		Status *ISPMetricsQueryResponseDataStatus `json:"status"`
	} `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// ISPMetricsQueryResponseDataStatus Query status (partialSuccess if some sites are inaccessible)
type ISPMetricsQueryResponseDataStatus string

// ISPMetricsQuerySiteItem Site query parameters
type ISPMetricsQuerySiteItem struct {
	// BeginTimestamp The earliest timestamp to retrieve data from (RFC3339 format)
	BeginTimestamp *time.Time `json:"beginTimestamp,omitempty"`

	// EndTimestamp The latest timestamp to retrieve data up to (RFC3339 format)
	EndTimestamp *time.Time `json:"endTimestamp,omitempty"`

	// HostId Host identifier
	HostId string `json:"hostId"`

	// SiteId Site identifier
	SiteId string `json:"siteId"`
}

// ISPMetricsResponse defines model for ISPMetricsResponse.
type ISPMetricsResponse struct {
	Data []ISPMetricItem `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// InternetIssues defines model for InternetIssues.
type InternetIssues struct {
	Periods *[]struct {
		// Index Time period index
		Index *int `json:"index,omitempty"`
	} `json:"periods,omitempty"`
}

// ReportedStateApp defines model for ReportedStateApp.
type ReportedStateApp struct {
	// ControllerStatus Controller status
	ControllerStatus *string `json:"controllerStatus,omitempty"`

	// Features App features map
	Features *map[string]bool `json:"features,omitempty"`

	// Flags App flags
	Flags            *[]string `json:"flags,omitempty"`
	IdentityFeatures *struct {
		HostingIdentityHubScore *int  `json:"hostingIdentityHubScore,omitempty"`
		Standard                *bool `json:"standard,omitempty"`
		Ucs                     *bool `json:"ucs,omitempty"`
		UcsAgent                *bool `json:"ucsAgent,omitempty"`
		UcsRemoteAccessViaUOS   *bool `json:"ucsRemoteAccessViaUOS,omitempty"`
		UnifiedAdminsUsersPage  *bool `json:"unifiedAdminsUsersPage,omitempty"`
	} `json:"identityFeatures,omitempty"`
	IdentityState *struct {
		EnterpriseActivated    *bool   `json:"enterpriseActivated,omitempty"`
		MigrationNeeded        *bool   `json:"migrationNeeded,omitempty"`
		MigrationStatus        *string `json:"migrationStatus,omitempty"`
		MigrationStatusMessage *string `json:"migrationStatusMessage,omitempty"`
		OrganizationManaged    *bool   `json:"organizationManaged,omitempty"`
		StandardActivated      *bool   `json:"standardActivated,omitempty"`
		UcsActivated           *bool   `json:"ucsActivated,omitempty"`
		UcsAgentActivated      *bool   `json:"ucsAgentActivated,omitempty"`
		UcsAgentVersion        *string `json:"ucsAgentVersion,omitempty"`
		UcsSetuped             *bool   `json:"ucsSetuped,omitempty"`
		UcsVersion             *string `json:"ucsVersion,omitempty"`
		UsersOrAdminsExist     *bool   `json:"usersOrAdminsExist,omitempty"`
	} `json:"identityState,omitempty"`
	IsConfigured *bool   `json:"isConfigured,omitempty"`
	IsInstalled  *bool   `json:"isInstalled,omitempty"`
	IsRunning    *bool   `json:"isRunning,omitempty"`
	Name         *string `json:"name,omitempty"`
	Port         *int    `json:"port,omitempty"`

	// Prefetch Prefetch resources list
	Prefetch *[]string `json:"prefetch,omitempty"`

	// SwaiVersion SWAI version number
	SwaiVersion *int `json:"swaiVersion,omitempty"`

	// Type App type
	Type *string `json:"type,omitempty"`

	// UiIcon UI icon path
	UiIcon *string `json:"uiIcon,omitempty"`

	// UiVersion UI version
	UiVersion *string `json:"uiVersion,omitempty"`

	// Version App version
	Version *string `json:"version,omitempty"`
}

// SDWANConfig defines model for SDWANConfig.
type SDWANConfig struct {
	// Hubs Array of hub configurations
	Hubs *[]SDWANEndpoint `json:"hubs,omitempty"`

	// Id Unique identifier of the SD-WAN config
	Id *string `json:"id,omitempty"`

	// Name Name of the SD-WAN config
	Name *string `json:"name,omitempty"`

	// Settings SD-WAN configuration settings
	Settings *SDWANSettings `json:"settings,omitempty"`

	// Spokes Array of spoke configurations
	Spokes *[]SDWANEndpoint `json:"spokes,omitempty"`

	// Type Type of SD-WAN config - Currently only supports sdwan-hbsp
	Type *SDWANConfigType `json:"type,omitempty"`

	// Variant SD-WAN variant (single, multi, etc.)
	Variant *string `json:"variant,omitempty"`
}

// SDWANConfigType Type of SD-WAN config - Currently only supports sdwan-hbsp
type SDWANConfigType string

// SDWANConfigResponse defines model for SDWANConfigResponse.
type SDWANConfigResponse struct {
	Data SDWANConfig `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SDWANConfigStatus SD-WAN configuration deployment status
type SDWANConfigStatus struct {
	// Errors Configuration-level errors
	Errors *[]string `json:"errors,omitempty"`

	// Fingerprint Configuration fingerprint
	Fingerprint *string `json:"fingerprint,omitempty"`

	// GenerateStatus Generation status
	GenerateStatus *string `json:"generateStatus,omitempty"`

	// Hubs Hub deployment statuses
	Hubs *[]SDWANHubStatus `json:"hubs,omitempty"`

	// Id SD-WAN configuration identifier
	Id *string `json:"id,omitempty"`

	// LastGeneratedAt Last generation timestamp
	LastGeneratedAt *int64 `json:"lastGeneratedAt,omitempty"`

	// Spokes Spoke deployment statuses
	Spokes *[]SDWANSpokeStatus `json:"spokes,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *int64 `json:"updatedAt,omitempty"`

	// Warnings Configuration-level warnings
	Warnings *[]string `json:"warnings,omitempty"`
}

// SDWANConfigStatusResponse defines model for SDWANConfigStatusResponse.
type SDWANConfigStatusResponse struct {
	// Data SD-WAN configuration deployment status
	Data SDWANConfigStatus `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SDWANConfigsResponse defines model for SDWANConfigsResponse.
type SDWANConfigsResponse struct {
	Data []SDWANConfig `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SDWANConnection Connection from spoke to hub
type SDWANConnection struct {
	// HubId Hub identifier
	HubId *string `json:"hubId,omitempty"`

	// Tunnels Array of tunnels to the hub
	Tunnels *[]SDWANTunnel `json:"tunnels,omitempty"`
}

// SDWANEndpoint SD-WAN hub or spoke endpoint configuration
type SDWANEndpoint struct {
	// HostId Host identifier
	HostId *string `json:"hostId,omitempty"`

	// HubsPriority Priority order of hubs (for spokes only)
	HubsPriority *[]string `json:"hubsPriority"`

	// Id Endpoint identifier
	Id *string `json:"id,omitempty"`

	// NetworkIds List of networks belonging to the hub
	NetworkIds *[]string `json:"networkIds,omitempty"`

	// PrimaryWan Primary WAN interface
	PrimaryWan *string `json:"primaryWan,omitempty"`

	// Routes Subnets in CIDR format
	Routes *[]string `json:"routes,omitempty"`

	// SiteId Site identifier
	SiteId *string `json:"siteId,omitempty"`

	// WanFailover Enable WAN failover
	WanFailover *bool `json:"wanFailover,omitempty"`
}

// SDWANHubStatus Hub deployment status
type SDWANHubStatus struct {
	// ApplyStatus Configuration apply status
	ApplyStatus *string `json:"applyStatus,omitempty"`

	// Errors Hub configuration errors
	Errors *[]string `json:"errors,omitempty"`

	// HostId Host identifier
	HostId *string `json:"hostId,omitempty"`

	// Id Hub endpoint identifier
	Id *string `json:"id,omitempty"`

	// Name Hub name
	Name *string `json:"name,omitempty"`

	// Networks Networks advertised by the hub
	Networks *[]SDWANNetwork `json:"networks,omitempty"`

	// NumberOfTunnelsUsedByOtherFeatures Number of tunnels used by other features
	NumberOfTunnelsUsedByOtherFeatures *int `json:"numberOfTunnelsUsedByOtherFeatures,omitempty"`

	// PrimaryWanStatus WAN interface status information
	PrimaryWanStatus *SDWANWanStatus `json:"primaryWanStatus,omitempty"`

	// Routes Routes advertised by the hub
	Routes *[]SDWANRoute `json:"routes,omitempty"`

	// SecondaryWanStatus WAN interface status information
	SecondaryWanStatus *SDWANWanStatus `json:"secondaryWanStatus,omitempty"`

	// SiteId Site identifier
	SiteId *string `json:"siteId,omitempty"`

	// Warnings Hub configuration warnings
	Warnings *[]string `json:"warnings,omitempty"`
}

// SDWANNetwork Network configuration in hub/spoke
type SDWANNetwork struct {
	// Errors Network configuration errors
	Errors *[]string `json:"errors,omitempty"`

	// Name Network name
	Name *string `json:"name,omitempty"`

	// NetworkId Network identifier
	NetworkId *string `json:"networkId,omitempty"`

	// Warnings Network configuration warnings
	Warnings *[]string `json:"warnings,omitempty"`
}

// SDWANRoute Route configuration in hub/spoke
type SDWANRoute struct {
	// Errors Route configuration errors
	Errors *[]string `json:"errors,omitempty"`

	// RouteValue Route in CIDR format
	RouteValue *string `json:"routeValue,omitempty"`

	// Warnings Route configuration warnings
	Warnings *[]string `json:"warnings,omitempty"`
}

// SDWANSettings SD-WAN configuration settings
type SDWANSettings struct {
	// HubsInterconnect Enable hubs interconnect
	HubsInterconnect *bool `json:"hubsInterconnect"`

	// SpokeStandardSettingsEnabled Enable spoke standard settings
	SpokeStandardSettingsEnabled *bool `json:"spokeStandardSettingsEnabled,omitempty"`

	// SpokeStandardSettingsValues Spoke standard settings values
	SpokeStandardSettingsValues *SDWANSpokeSettings `json:"spokeStandardSettingsValues"`

	// SpokeToHubRouting Spoke to hub routing mode (geo, etc.)
	SpokeToHubRouting *string `json:"spokeToHubRouting,omitempty"`

	// SpokeToHubTunnelsMode Spoke to hub tunnels mode (scalable, etc.)
	SpokeToHubTunnelsMode *string `json:"spokeToHubTunnelsMode,omitempty"`

	// SpokesAutoScaleAndNatEnabled Enable auto-scale and NAT for spokes
	SpokesAutoScaleAndNatEnabled *bool `json:"spokesAutoScaleAndNatEnabled,omitempty"`

	// SpokesAutoScaleAndNatRange Auto-scale and NAT IP range in CIDR format
	SpokesAutoScaleAndNatRange *string `json:"spokesAutoScaleAndNatRange,omitempty"`

	// SpokesIsolate Spoke isolation setting
	SpokesIsolate *bool `json:"spokesIsolate,omitempty"`
}

// SDWANSpokeSettings Spoke standard settings values
type SDWANSpokeSettings map[string]interface{}

// SDWANSpokeStatus Spoke deployment status
type SDWANSpokeStatus struct {
	// ApplyStatus Configuration apply status
	ApplyStatus *string `json:"applyStatus,omitempty"`

	// Connections Connections from spoke to hubs
	Connections *[]SDWANConnection `json:"connections,omitempty"`

	// Errors Spoke configuration errors
	Errors *[]string `json:"errors,omitempty"`

	// HostId Host identifier
	HostId *string `json:"hostId,omitempty"`

	// Id Spoke endpoint identifier
	Id *string `json:"id,omitempty"`

	// Name Spoke name
	Name *string `json:"name,omitempty"`

	// Networks Networks advertised by the spoke
	Networks *[]SDWANNetwork `json:"networks,omitempty"`

	// NumberOfTunnelsUsedByOtherFeatures Number of tunnels used by other features
	NumberOfTunnelsUsedByOtherFeatures *int `json:"numberOfTunnelsUsedByOtherFeatures,omitempty"`

	// PrimaryWanStatus WAN interface status information
	PrimaryWanStatus *SDWANWanStatus `json:"primaryWanStatus,omitempty"`

	// Routes Routes advertised by the spoke
	Routes *[]SDWANRoute `json:"routes,omitempty"`

	// SecondaryWanStatus WAN interface status information
	SecondaryWanStatus *SDWANWanStatus `json:"secondaryWanStatus,omitempty"`

	// SiteId Site identifier
	SiteId *string `json:"siteId,omitempty"`

	// Warnings Spoke configuration warnings
	Warnings *[]string `json:"warnings,omitempty"`
}

// SDWANTunnel Tunnel status between spoke and hub
type SDWANTunnel struct {
	// HubWanId Hub WAN interface ID
	HubWanId *string `json:"hubWanId,omitempty"`

	// SpokeWanId Spoke WAN interface ID
	SpokeWanId *string `json:"spokeWanId,omitempty"`

	// Status Tunnel status (connected, disconnected, etc.)
	Status *string `json:"status,omitempty"`
}

// SDWANWanStatus WAN interface status information
type SDWANWanStatus struct {
	// InternetIssues List of internet connectivity issues
	InternetIssues *[]string `json:"internetIssues"`

	// Ip WAN IP address
	Ip *string `json:"ip,omitempty"`

	// Latency WAN latency in milliseconds
	Latency *int `json:"latency"`

	// WanId WAN interface identifier
	WanId *string `json:"wanId,omitempty"`
}

// Site defines model for Site.
type Site struct {
	// HostId Unique identifier of the host device managing this site
	HostId *string `json:"hostId,omitempty"`

	// IsOwner Indicates if the current user is the owner of this site
	IsOwner *bool     `json:"isOwner,omitempty"`
	Meta    *SiteMeta `json:"meta,omitempty"`

	// Permission Permission level of the current user for this site (admin, readonly, etc.)
	Permission *string `json:"permission,omitempty"`

	// SiteId Unique identifier of the site
	SiteId     *string         `json:"siteId,omitempty"`
	Statistics *SiteStatistics `json:"statistics,omitempty"`
}

// SiteMeta defines model for SiteMeta.
type SiteMeta struct {
	// Desc Site description
	Desc *string `json:"desc,omitempty"`

	// GatewayMac Gateway MAC address
	GatewayMac *string `json:"gatewayMac,omitempty"`

	// Name Site name
	Name *string `json:"name,omitempty"`

	// Timezone Site timezone
	Timezone *string `json:"timezone,omitempty"`
}

// SiteStatistics defines model for SiteStatistics.
type SiteStatistics struct {
	Counts *struct {
		CriticalNotification *int `json:"criticalNotification,omitempty"`
		GatewayDevice        *int `json:"gatewayDevice,omitempty"`
		GuestClient          *int `json:"guestClient,omitempty"`
		LanConfiguration     *int `json:"lanConfiguration,omitempty"`
		OfflineDevice        *int `json:"offlineDevice,omitempty"`
		OfflineGatewayDevice *int `json:"offlineGatewayDevice,omitempty"`
		OfflineWifiDevice    *int `json:"offlineWifiDevice,omitempty"`
		OfflineWiredDevice   *int `json:"offlineWiredDevice,omitempty"`
		PendingUpdateDevice  *int `json:"pendingUpdateDevice,omitempty"`
		TotalDevice          *int `json:"totalDevice,omitempty"`
		WanConfiguration     *int `json:"wanConfiguration,omitempty"`
		WifiClient           *int `json:"wifiClient,omitempty"`
		WifiConfiguration    *int `json:"wifiConfiguration,omitempty"`
		WifiDevice           *int `json:"wifiDevice,omitempty"`
		WiredClient          *int `json:"wiredClient,omitempty"`
		WiredDevice          *int `json:"wiredDevice,omitempty"`
	} `json:"counts,omitempty"`
	Gateway *struct {
		HardwareId *openapi_types.UUID `json:"hardwareId,omitempty"`

		// InspectionState Inspection state (off, on, etc.)
		InspectionState *string `json:"inspectionState,omitempty"`

		// IpsMode IPS mode (ids, ips, etc.)
		IpsMode      *string `json:"ipsMode,omitempty"`
		IpsSignature *struct {
			RulesCount *int `json:"rulesCount,omitempty"`

			// Type Signature type (ET, etc.)
			Type *string `json:"type,omitempty"`
		} `json:"ipsSignature,omitempty"`

		// Shortname Gateway model shortname
		Shortname *string `json:"shortname,omitempty"`
	} `json:"gateway,omitempty"`

	// InternetIssues List of internet issues
	InternetIssues *[]interface{} `json:"internetIssues,omitempty"`
	IspInfo        *struct {
		// Name ISP name
		Name *string `json:"name,omitempty"`

		// Organization ISP organization
		Organization *string `json:"organization,omitempty"`
	} `json:"ispInfo,omitempty"`
	Percentages *struct {
		// TxRetry TX retry percentage
		TxRetry *float32 `json:"txRetry,omitempty"`

		// WanUptime WAN uptime percentage
		WanUptime *float32 `json:"wanUptime,omitempty"`
	} `json:"percentages,omitempty"`
	WanMagic *struct {
		Available  *bool `json:"available,omitempty"`
		Enabled    *bool `json:"enabled,omitempty"`
		Subscribed *bool `json:"subscribed,omitempty"`
	} `json:"wanMagic,omitempty"`
	Wans *map[string]struct {
		// ExternalIp External IP address
		ExternalIp *string `json:"externalIp,omitempty"`
		IspInfo    *struct {
			Name         *string `json:"name,omitempty"`
			Organization *string `json:"organization,omitempty"`
		} `json:"ispInfo,omitempty"`
		WanIssues *[]interface{} `json:"wanIssues,omitempty"`

		// WanUptime WAN uptime percentage
		WanUptime *float32 `json:"wanUptime,omitempty"`
	} `json:"wans,omitempty"`
}

// SitesResponse defines model for SitesResponse.
type SitesResponse struct {
	Data []Site `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// NextToken Pagination token for fetching the next set of results
	NextToken *string `json:"nextToken,omitempty"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Data The actual response payload
	Data map[string]interface{} `json:"data"`

	// HttpStatusCode HTTP status code
	HttpStatusCode int `json:"httpStatusCode"`

	// TraceId Unique identifier for debugging purposes
	TraceId string `json:"traceId"`
}

// UidbInfo defines model for UidbInfo.
type UidbInfo struct {
	Guid   *openapi_types.UUID `json:"guid"`
	IconId *openapi_types.UUID `json:"iconId,omitempty"`
	Id     *openapi_types.UUID `json:"id,omitempty"`

	// Images Image hash map
	Images *map[string]string `json:"images,omitempty"`
}

// UserDataFeatures defines model for UserDataFeatures.
type UserDataFeatures struct {
	DeviceGroups *bool `json:"deviceGroups,omitempty"`
	Floorplan    *struct {
		CanEdit *bool `json:"canEdit,omitempty"`
		CanView *bool `json:"canView,omitempty"`
	} `json:"floorplan,omitempty"`
	ManageApplications *bool `json:"manageApplications,omitempty"`
	Notifications      *bool `json:"notifications,omitempty"`
	Webrtc             *struct {
		IceRestart       *bool `json:"iceRestart,omitempty"`
		MediaStreams     *bool `json:"mediaStreams,omitempty"`
		MediaStreamsAV1  *bool `json:"mediaStreamsAV1,omitempty"`
		MediaStreamsH265 *bool `json:"mediaStreamsH265,omitempty"`
		TwoWayAudio      *bool `json:"twoWayAudio,omitempty"`
	} `json:"webrtc,omitempty"`
}

// BadGateway defines model for BadGateway.
type BadGateway = ErrorResponse

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// RateLimited defines model for RateLimited.
type RateLimited = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// GetISPMetricsParams defines parameters for GetISPMetrics.
type GetISPMetricsParams struct {
	// BeginTimestamp The earliest timestamp to retrieve data from (RFC3339 format)
	BeginTimestamp *time.Time `form:"beginTimestamp,omitempty" json:"beginTimestamp,omitempty"`

	// EndTimestamp The latest timestamp to retrieve data up to (RFC3339 format)
	EndTimestamp *time.Time `form:"endTimestamp,omitempty" json:"endTimestamp,omitempty"`

	// Duration Specifies the time range of metrics to retrieve, starting from when the request is made.
	// Supports 24h for 5-minute metrics, and 7d or 30d for 1-hour metrics.
	// This parameter cannot be used with beginTimestamp or endTimestamp.
	Duration *GetISPMetricsParamsDuration `form:"duration,omitempty" json:"duration,omitempty"`
}

// GetISPMetricsParamsDuration defines parameters for GetISPMetrics.
type GetISPMetricsParamsDuration string

// GetISPMetricsParamsType defines parameters for GetISPMetrics.
type GetISPMetricsParamsType string

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// HostIds List of host IDs to filter the results
	HostIds *[]string `form:"hostIds,omitempty" json:"hostIds,omitempty"`

	// Time Last processed timestamp of devices in RFC3339 format
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`

	// PageSize Number of items to return per page
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination to retrieve the next set of results
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListHostsParams defines parameters for ListHosts.
type ListHostsParams struct {
	// PageSize Number of items to return per page
	PageSize *string `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination to retrieve the next set of results
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// QueryISPMetricsJSONRequestBody defines body for QueryISPMetrics for application/json ContentType.
type QueryISPMetricsJSONRequestBody = ISPMetricsQuery

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetISPMetrics request
	GetISPMetrics(ctx context.Context, pType GetISPMetricsParamsType, params *GetISPMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryISPMetricsWithBody request with any body
	QueryISPMetricsWithBody(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryISPMetrics(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSDWANConfigs request
	ListSDWANConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSDWANConfigById request
	GetSDWANConfigById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSDWANConfigStatus request
	GetSDWANConfigStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDevices request
	ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHosts request
	ListHosts(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostById request
	GetHostById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSites request
	ListSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetISPMetrics(ctx context.Context, pType GetISPMetricsParamsType, params *GetISPMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetISPMetricsRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryISPMetricsWithBody(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryISPMetricsRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryISPMetrics(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryISPMetricsRequest(c.Server, pType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSDWANConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSDWANConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSDWANConfigById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSDWANConfigByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSDWANConfigStatus(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSDWANConfigStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHosts(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetISPMetricsRequest generates requests for GetISPMetrics
func NewGetISPMetricsRequest(server string, pType GetISPMetricsParamsType, params *GetISPMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/isp-metrics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeginTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "beginTimestamp", runtime.ParamLocationQuery, *params.BeginTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTimestamp", runtime.ParamLocationQuery, *params.EndTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryISPMetricsRequest calls the generic QueryISPMetrics builder with application/json body
func NewQueryISPMetricsRequest(server string, pType string, body QueryISPMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryISPMetricsRequestWithBody(server, pType, "application/json", bodyReader)
}

// NewQueryISPMetricsRequestWithBody generates requests for QueryISPMetrics with any type of body
func NewQueryISPMetricsRequestWithBody(server string, pType string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/isp-metrics/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSDWANConfigsRequest generates requests for ListSDWANConfigs
func NewListSDWANConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSDWANConfigByIdRequest generates requests for GetSDWANConfigById
func NewGetSDWANConfigByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSDWANConfigStatusRequest generates requests for GetSDWANConfigStatus
func NewGetSDWANConfigStatusRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ea/sd-wan-configs/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDevicesRequest generates requests for ListDevices
func NewListDevicesRequest(server string, params *ListDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HostIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostIds", runtime.ParamLocationQuery, *params.HostIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHostsRequest generates requests for ListHosts
func NewListHostsRequest(server string, params *ListHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostByIdRequest generates requests for GetHostById
func NewGetHostByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSitesRequest generates requests for ListSites
func NewListSitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetISPMetricsWithResponse request
	GetISPMetricsWithResponse(ctx context.Context, pType GetISPMetricsParamsType, params *GetISPMetricsParams, reqEditors ...RequestEditorFn) (*GetISPMetricsResponse, error)

	// QueryISPMetricsWithBodyWithResponse request with any body
	QueryISPMetricsWithBodyWithResponse(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error)

	QueryISPMetricsWithResponse(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error)

	// ListSDWANConfigsWithResponse request
	ListSDWANConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSDWANConfigsResponse, error)

	// GetSDWANConfigByIdWithResponse request
	GetSDWANConfigByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigByIdResponse, error)

	// GetSDWANConfigStatusWithResponse request
	GetSDWANConfigStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigStatusResponse, error)

	// ListDevicesWithResponse request
	ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error)

	// ListHostsWithResponse request
	ListHostsWithResponse(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*ListHostsResponse, error)

	// GetHostByIdWithResponse request
	GetHostByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostByIdResponse, error)

	// ListSitesWithResponse request
	ListSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSitesResponse, error)
}

type GetISPMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ISPMetricsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetISPMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetISPMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryISPMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ISPMetricsQueryResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r QueryISPMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryISPMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSDWANConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigsResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListSDWANConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSDWANConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSDWANConfigByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetSDWANConfigByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSDWANConfigByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSDWANConfigStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDWANConfigStatusResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetSDWANConfigStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSDWANConfigStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevicesResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostsResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HostResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r GetHostByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitesResponse
	JSON401      *Unauthorized
	JSON429      *RateLimited
	JSON500      *InternalServerError
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ListSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetISPMetricsWithResponse request returning *GetISPMetricsResponse
func (c *ClientWithResponses) GetISPMetricsWithResponse(ctx context.Context, pType GetISPMetricsParamsType, params *GetISPMetricsParams, reqEditors ...RequestEditorFn) (*GetISPMetricsResponse, error) {
	rsp, err := c.GetISPMetrics(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetISPMetricsResponse(rsp)
}

// QueryISPMetricsWithBodyWithResponse request with arbitrary body returning *QueryISPMetricsResponse
func (c *ClientWithResponses) QueryISPMetricsWithBodyWithResponse(ctx context.Context, pType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error) {
	rsp, err := c.QueryISPMetricsWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryISPMetricsResponse(rsp)
}

func (c *ClientWithResponses) QueryISPMetricsWithResponse(ctx context.Context, pType string, body QueryISPMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryISPMetricsResponse, error) {
	rsp, err := c.QueryISPMetrics(ctx, pType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryISPMetricsResponse(rsp)
}

// ListSDWANConfigsWithResponse request returning *ListSDWANConfigsResponse
func (c *ClientWithResponses) ListSDWANConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSDWANConfigsResponse, error) {
	rsp, err := c.ListSDWANConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSDWANConfigsResponse(rsp)
}

// GetSDWANConfigByIdWithResponse request returning *GetSDWANConfigByIdResponse
func (c *ClientWithResponses) GetSDWANConfigByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigByIdResponse, error) {
	rsp, err := c.GetSDWANConfigById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSDWANConfigByIdResponse(rsp)
}

// GetSDWANConfigStatusWithResponse request returning *GetSDWANConfigStatusResponse
func (c *ClientWithResponses) GetSDWANConfigStatusWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSDWANConfigStatusResponse, error) {
	rsp, err := c.GetSDWANConfigStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSDWANConfigStatusResponse(rsp)
}

// ListDevicesWithResponse request returning *ListDevicesResponse
func (c *ClientWithResponses) ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error) {
	rsp, err := c.ListDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDevicesResponse(rsp)
}

// ListHostsWithResponse request returning *ListHostsResponse
func (c *ClientWithResponses) ListHostsWithResponse(ctx context.Context, params *ListHostsParams, reqEditors ...RequestEditorFn) (*ListHostsResponse, error) {
	rsp, err := c.ListHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHostsResponse(rsp)
}

// GetHostByIdWithResponse request returning *GetHostByIdResponse
func (c *ClientWithResponses) GetHostByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHostByIdResponse, error) {
	rsp, err := c.GetHostById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostByIdResponse(rsp)
}

// ListSitesWithResponse request returning *ListSitesResponse
func (c *ClientWithResponses) ListSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSitesResponse, error) {
	rsp, err := c.ListSites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSitesResponse(rsp)
}

// ParseGetISPMetricsResponse parses an HTTP response from a GetISPMetricsWithResponse call
func ParseGetISPMetricsResponse(rsp *http.Response) (*GetISPMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetISPMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ISPMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseQueryISPMetricsResponse parses an HTTP response from a QueryISPMetricsWithResponse call
func ParseQueryISPMetricsResponse(rsp *http.Response) (*QueryISPMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryISPMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ISPMetricsQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListSDWANConfigsResponse parses an HTTP response from a ListSDWANConfigsWithResponse call
func ParseListSDWANConfigsResponse(rsp *http.Response) (*ListSDWANConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSDWANConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetSDWANConfigByIdResponse parses an HTTP response from a GetSDWANConfigByIdWithResponse call
func ParseGetSDWANConfigByIdResponse(rsp *http.Response) (*GetSDWANConfigByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSDWANConfigByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetSDWANConfigStatusResponse parses an HTTP response from a GetSDWANConfigStatusWithResponse call
func ParseGetSDWANConfigStatusResponse(rsp *http.Response) (*GetSDWANConfigStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSDWANConfigStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDWANConfigStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListDevicesResponse parses an HTTP response from a ListDevicesWithResponse call
func ParseListDevicesResponse(rsp *http.Response) (*ListDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListHostsResponse parses an HTTP response from a ListHostsWithResponse call
func ParseListHostsResponse(rsp *http.Response) (*ListHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetHostByIdResponse parses an HTTP response from a GetHostByIdWithResponse call
func ParseGetHostByIdResponse(rsp *http.Response) (*GetHostByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseListSitesResponse parses an HTTP response from a ListSitesWithResponse call
func ParseListSitesResponse(rsp *http.Response) (*ListSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimited
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
